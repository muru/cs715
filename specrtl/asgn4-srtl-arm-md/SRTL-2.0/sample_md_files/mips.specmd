
list any_extend.c_iter [sign_extend, zero_extend]
list any_shiftrt.c_iter [ashiftrt, lshiftrt]
list any_shift.c_iter [ashift, ashiftrt, lshiftrt]
list any_div.c_iter [div, udiv]
list any_mod.c_iter [mod, umod]
list fcond.c_iter [unordered, uneq, unlt, unle, eq, lt, le]
list swapped_fcond.c_iter [ge, gt, unge, ungt]
list equality_op.c_iter [eq, ne]
list any_gt.c_iter [gt, gtu]
list any_ge.c_iter [ge, geu]
list any_lt.c_iter [lt, ltu]
list any_le.c_iter [le, leu]

concrete trap.insn instantiates trap_if 
{
	root (const_int:1, const_int:0);
}
{:
  ""
{
  if (ISA_HAS_COND_TRAP)
    return "teq\t$0,$0";
  else if (TARGET_MIPS16)
    return "break 0";
  else
    return "break";
}
  [(set_attr "type" "trap")]
:}

abstract trap_if_match_operator extends trap_if {
	root.1:=match_operator;
}

concrete ctrap<mode>4.exp instantiates trap_if_match_operator {
	root ((0=comparison_operator,1=reg_or_0_operand:GPR:"",
		2=arith_operand:GPR:""),3=const_0_operand:NULL:"");
}
{:
  "ISA_HAS_COND_TRAP"
{
  mips_expand_conditional_trap (operands[0]);
  DONE;
}
:}

concrete *conditional_trap<mode>.insn instantiates trap_if_match_operator{
	root ((0=trap_comparison_operator, 1=reg_or_0_operand:GPR:"dJ",
		2=arith_operand:GPR:"dI"), const_int:0);
	root.1.mode:=GPR;
}
{:
  "ISA_HAS_COND_TRAP"
  "t%C0\t%z1,%2"
  [(set_attr "type" "trap")]
:}
{:

;;
;;  ....................
;;
;;	ADDITION
;;
;;  ....................
;;
:}

concrete add<mode>3.insn instantiates set_plus2 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f",
		register_operand:ANYF:"f");
	root.2.mode:=ANYF;
}
{:
  ""
  "add.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete add<mode>3.exp overrides add<mode>3.insn {
	ANYF->GPR; root.2.mode:=GPR; root.2.2.predicate:=arith_operand;
	allconstraints:=("","","");
}
{:
  ""
:}

concrete *add<mode>3.insn overrides add<mode>3.exp {
	root.2.1.predicate:=register_operand; root.2.2.predicate:=arith_operand;
	allconstraints:=("=d,d", "d,d", "d,Q");
}
{:
  "!TARGET_MIPS16"
  "@
    <d>addu\t%0,%1,%2
    <d>addiu\t%0,%1,%2"
  [(set_attr "alu_type" "add")
   (set_attr "mode" "<MODE>")]
:}

concrete *add<mode>3_mips16.insn overrides *add<mode>3.insn {
	root.2.1.predicate:=register_operand; root.2.2.predicate:=arith_operand;
	allconstraints:=("=ks,d,d,d,d","ks,ks,0,d,d","Q,Q,Q,O,d");
}
{:
  "TARGET_MIPS16"
  "@
    <d>addiu\t%0,%2
    <d>addiu\t%0,%1,%2
    <d>addiu\t%0,%2
    <d>addiu\t%0,%1,%2
    <d>addu\t%0,%1,%2"
  [(set_attr "alu_type" "add")
   (set_attr "mode" "<MODE>")
   (set_attr_alternative "length"
		[(if_then_else (match_operand 2 "m16_simm8_8")
			       (const_int 4)
			       (const_int 8))
		 (if_then_else (match_operand 2 "m16_uimm<si8_di5>_4")
			       (const_int 4)
			       (const_int 8))
		 (if_then_else (match_operand 2 "m16_simm<si8_di5>_1")
			       (const_int 4)
			       (const_int 8))
		 (if_then_else (match_operand 2 "m16_simm4_1")
			       (const_int 4)
			       (const_int 8))
		 (const_int 4)])]
:}

{:
;; On the mips16, we can sometimes split an add of a constant which is
;; a 4 byte instruction into two adds which are both 2 byte
;; instructions.  There are two cases: one where we are adding a
;; constant plus a register to another register, and one where we are
;; simply adding a constant to a register.
:}

abstract set_plus2_x2 extends sequence {
	root.1:=set_plus2; root.2:=set_plus2;
}

concrete .split instantiates.in set_plus2 {
	root (d_operand:SI:"",duplicate 0,const_int_operand:SI:"");
	root.2.mode:=SI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && ((INTVAL (operands[1]) > 0x7f
	&& INTVAL (operands[1]) <= 0x7f + 0x7f)
       || (INTVAL (operands[1]) < - 0x80
	   && INTVAL (operands[1]) >= - 0x80 - 0x80))"
:}
instantiates.out set_plus2_x2 {
	root (duplicate 0, duplicate 0, duplicate 1,
		(duplicate 0, duplicate 0, duplicate 2)); 
	root.1.2.mode:=SI; root.2.2.mode:=SI;
}
cmd_spec.out 
{:
{
  HOST_WIDE_INT val = INTVAL (operands[1]);

  if (val >= 0)
    {
      operands[1] = GEN_INT (0x7f);
      operands[2] = GEN_INT (val - 0x7f);
    }
  else
    {
      operands[1] = GEN_INT (- 0x80);
      operands[2] = GEN_INT (val + 0x80);
    }
}
:}

concrete .split instantiates.in set_plus2 {
	root (d_operand:SI:"", d_operand:SI:"", const_int_operand:SI:"");
	root.2.mode:=SI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && REGNO (operands[0]) != REGNO (operands[1])
   && ((INTVAL (operands[2]) > 0x7
	&& INTVAL (operands[2]) <= 0x7 + 0x7f)
       || (INTVAL (operands[2]) < - 0x8
	   && INTVAL (operands[2]) >= - 0x8 - 0x80))"
:}
instantiates.out set_plus2_x2 {
	root (duplicate 0, duplicate 1, duplicate 2,
		(duplicate 0, duplicate 0, duplicate 3));
	root.1.2.mode:=SI; root.2.2.mode:=SI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[2]);

  if (val >= 0)
    {
      operands[2] = GEN_INT (0x7);
      operands[3] = GEN_INT (val - 0x7);
    }
  else
    {
      operands[2] = GEN_INT (- 0x8);
      operands[3] = GEN_INT (val + 0x8);
    }
}
:}

concrete .split instantiates.in set_plus2 {
	root (d_operand:DI:"", duplicate 0, const_int_operand:DI:"");
	root.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && TARGET_64BIT && reload_completed && !TARGET_DEBUG_D_MODE
   && ((INTVAL (operands[1]) > 0xf
	&& INTVAL (operands[1]) <= 0xf + 0xf)
       || (INTVAL (operands[1]) < - 0x10
	   && INTVAL (operands[1]) >= - 0x10 - 0x10))"
:}
instantiates.out set_plus2_x2 {
	root (duplicate 0, duplicate 0, duplicate 1,
		(duplicate 0, duplicate 0, duplicate 2));
	root.1.2.mode:=DI;	root.2.2.mode:=DI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[1]);

  if (val >= 0)
    {
      operands[1] = GEN_INT (0xf);
      operands[2] = GEN_INT (val - 0xf);
    }
  else
    {
      operands[1] = GEN_INT (- 0x10);
      operands[2] = GEN_INT (val + 0x10);
    }
}
:}

concrete .split instantiates.in set_plus2 {
	root (d_operand:DI:"",d_operand:DI:"",const_int_operand:DI:"");
	root.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && TARGET_64BIT && reload_completed && !TARGET_DEBUG_D_MODE
   && REGNO (operands[0]) != REGNO (operands[1])
   && ((INTVAL (operands[2]) > 0x7
	&& INTVAL (operands[2]) <= 0x7 + 0xf)
       || (INTVAL (operands[2]) < - 0x8
	   && INTVAL (operands[2]) >= - 0x8 - 0x10))"
:}
instantiates.out set_plus2_x2 {
	root (duplicate 0,duplicate 1,duplicate 2,
		(duplicate 0,duplicate 0,duplicate 3));
	root.1.2.mode:=DI; root.2.2.mode:=DI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[2]);

  if (val >= 0)
    {
      operands[2] = GEN_INT (0x7);
      operands[3] = GEN_INT (val - 0x7);
    }
  else
    {
      operands[2] = GEN_INT (- 0x8);
      operands[3] = GEN_INT (val + 0x8);
    }
}
:}

abstract set_sign_extend2_plus2 extends set_sign_extend2 {
	root.2.1:=plus;
}

concrete *addsi3_extended.insn instantiates set_sign_extend2_plus2 {
	root (register_operand:DI:"=d,d", register_operand:SI:"d,d",
		arith_operand:SI:"d,Q");	root.2.mode:=DI; root.2.1.mode:=SI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16"
  "@
    addu\t%0,%1,%2
    addiu\t%0,%1,%2"
  [(set_attr "alu_type" "add")
   (set_attr "mode" "SI")]
:}
{:
;; Split this insn so that the addiu splitters can have a crack at it.
;; Use a conservative length estimate until the split.
:}

concrete *addsi3_extended_mips16.insn_and_split instantiates.in set_sign_extend2_plus2 {
	root (register_operand:DI:"=d,d,d", register_operand:SI:"0,d,d",
		arith_operand:SI:"Q,O,d"); root.2.mode:=DI; root.2.1.mode:=SI;
}
cmd_spec.in
{:
  "TARGET_64BIT && TARGET_MIPS16"
  "#"
  "&& reload_completed"
:}
instantiates.out set_plus2 {
	root (duplicate 3, duplicate 1, duplicate 2); root.2.mode:=SI;
}
cmd_spec.out
{:
  { operands[3] = gen_lowpart (SImode, operands[0]); }
  [(set_attr "alu_type" "add")
   (set_attr "mode" "SI")
   (set_attr "extended_mips16" "yes")]
:}

{:
;; Combiner patterns for unsigned byte-add.
:}

abstract set_zero_extend2 extends set {
	root.2:=zero_extend;
}

abstract set_zero_extend2_subreg_plus extends set_zero_extend2 {
	root.2.1:=subreg; root.2.1.1:=plus;
}

concrete *baddu_si_eb.insn instantiates set_zero_extend2_subreg_plus {
	root (register_operand:SI:"=d", register_operand:SI:"d", register_operand:SI:"d",
		3); root.2.mode:=SI; root.2.1.mode:=QI; root.2.1.1.mode:=SI;
}
{:
  "ISA_HAS_BADDU && BYTES_BIG_ENDIAN"
  "baddu\\t%0,%1,%2"
  [(set_attr "alu_type" "add")]
:}

concrete *baddu_si_el.insn instantiates set_zero_extend2_subreg_plus {
	root (register_operand:SI:"=d", register_operand:SI:"d", register_operand:SI:"d",
		0); root.2.mode:=SI; root.2.1.mode:=QI; root.2.1.1.mode:=SI;	
}
{:
  "ISA_HAS_BADDU && !BYTES_BIG_ENDIAN"
  "baddu\\t%0,%1,%2"
  [(set_attr "alu_type" "add")]
:}

abstract set_zero_extend2_truncate_plus extends set_zero_extend2_subreg_plus {
	root.2.1:=truncate; root.2.1.1:=plus;
}

concrete *baddu_di<mode>.insn instantiates set_zero_extend2_truncate_plus {
	root (register_operand:GPR:"=d", register_operand:DI:"d", register_operand:DI:"d");
	root.2.mode:=GPR; root.2.1.mode:=QI; root.2.1.1.mode:=DI;
}
{:
  "ISA_HAS_BADDU && TARGET_64BIT"
  "baddu\\t%0,%1,%2"
  [(set_attr "alu_type" "add")]
:}

{:

;;
;;  ....................
;;
;;	SUBTRACTION
;;
;;  ....................
;;
:}
concrete sub<mode>3.insn instantiates set_minus2 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f", register_operand:ANYF:"f");
	root.2.mode:=ANYF;
}
{:
  ""
  "sub.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete sub<mode>3.insn overrides sub<mode>3.insn {
	ANYF->GPR; allconstraints:= ("=d", "d", "d");
}
{:
  ""
  "<d>subu\t%0,%1,%2"
  [(set_attr "alu_type" "sub")
   (set_attr "mode" "<MODE>")]
:}

abstract set_sign_extend2_minus extends set_sign_extend2 {
	root.2.1:=minus;
}

concrete *subsi3_extended.insn instantiates set_sign_extend2_minus {
	root (register_operand:DI:"=d", register_operand:SI:"d",
		register_operand:SI:"d"); root.2.mode:=DI; root.2.1.mode:=SI;
}
{:
  "TARGET_64BIT"
  "subu\t%0,%1,%2"
  [(set_attr "alu_type" "sub")
   (set_attr "mode" "DI")]
:}

{:

;;
;;  ....................
;;
;;	MULTIPLICATION
;;
;;  ....................
;;
:}

concrete mul<mode>3.exp instantiates set_mult2 {
	root (register_operand:SCALARF:"", register_operand:SCALARF:"",
		register_operand:SCALARF:""); root.2.mode:=SCALARF;
}
{:
  ""
  ""
:}

concrete *mul<mode>3.insn overrides mul<mode>3.exp {
	allconstraints:= ("=f", "f", "f");
}
{:
  "!TARGET_4300_MUL_FIX"
  "mul.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmul")
   (set_attr "mode" "<MODE>")]
:}
{:
;; Early VR4300 silicon has a CPU bug where multiplies with certain
;; operands may corrupt immediately following multiplies. This is a
;; simple fix to insert NOPs.
:}

concrete *mul<mode>3_r4300.insn overrides *mul<mode>3.insn {
	root.2.mode:=SCALARF;
}
{:
  "TARGET_4300_MUL_FIX"
  "mul.<fmt>\t%0,%1,%2\;nop"
  [(set_attr "type" "fmul")
   (set_attr "mode" "<MODE>")
   (set_attr "length" "8")]
:}

concrete mulv2sf3.insn overrides *mul<mode>3.insn {
	SCALARF->V2SF;
}
{:
  "TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT"
  "mul.ps\t%0,%1,%2"
  [(set_attr "type" "fmul")
   (set_attr "mode" "SF")]
:}
{:
;; The original R4000 has a cpu bug.  If a double-word or a variable
;; shift executes while an integer multiplication is in progress, the
;; shift may give an incorrect result.  Avoid this by keeping the mflo
;; with the mult on the R4000.
;;
;; From "MIPS R4000PC/SC Errata, Processor Revision 2.2 and 3.0"
;; (also valid for MIPS R4000MC processors):
;;
;; "16. R4000PC, R4000SC: Please refer to errata 28 for an update to
;;	this errata description.
;;	The following code sequence causes the R4000 to incorrectly
;;	execute the Double Shift Right Arithmetic 32 (dsra32)
;;	instruction.  If the dsra32 instruction is executed during an
;;	integer multiply, the dsra32 will only shift by the amount in
;;	specified in the instruction rather than the amount plus 32
;;	bits.
;;	instruction 1:		mult	rs,rt		integer multiply
;;	instruction 2-12:	dsra32	rd,rt,rs	doubleword shift
;;							right arithmetic + 32
;;	Workaround: A dsra32 instruction placed after an integer
;;	multiply should not be one of the 11 instructions after the
;;	multiply instruction."
;;
;; and:
;;
;; "28. R4000PC, R4000SC: The text from errata 16 should be replaced by
;;	the following description.
;;	All extended shifts (shift by n+32) and variable shifts (32 and
;;	64-bit versions) may produce incorrect results under the
;;	following conditions:
;;	1) An integer multiply is currently executing
;;	2) These types of shift instructions are executed immediately
;;	   following an integer divide instruction.
;;	Workaround:
;;	1) Make sure no integer multiply is running wihen these
;;	   instruction are executed.  If this cannot be predicted at
;;	   compile time, then insert a "mfhi" to R0 instruction
;;	   immediately after the integer multiply instruction.  This
;;	   will cause the integer multiply to complete before the shift
;;	   is executed.
;;	2) Separate integer divide and these two classes of shift
;;	   instructions by another instruction or a noop."
;;
;; These processors have PRId values of 0x00004220 and 0x00004300,
;; respectively.
:}

concrete mul<mode>3.exp overrides mul<mode>3.exp  {
	SCALARF->GPR;
}
{:
  ""
{
  rtx lo;

  if (TARGET_LOONGSON_2EF || TARGET_LOONGSON_3A)
    emit_insn (gen_mul<mode>3_mul3_loongson (operands[0], operands[1],
                                             operands[2]));
  else if (ISA_HAS_<D>MUL3)
    emit_insn (gen_mul<mode>3_mul3 (operands[0], operands[1], operands[2]));
  else if (TARGET_MIPS16)
    {
      lo = gen_rtx_REG (<MODE>mode, LO_REGNUM);
      emit_insn (gen_mul<mode>3_internal (lo, operands[1], operands[2]));
      emit_move_insn (operands[0], lo);
    }
  else if (TARGET_FIX_R4000)
    emit_insn (gen_mul<mode>3_r4000 (operands[0], operands[1], operands[2]));
  else
    emit_insn
      (gen_mul<mode>3_internal (operands[0], operands[1], operands[2]));
  DONE;
}
:}

concrete mul<mode>3_mul3_loongson.insn overrides mul<mode>3.exp {
	allconstraints:=("=d", "d", "d");
}
{:
  "TARGET_LOONGSON_2EF || TARGET_LOONGSON_3A"
{
  if (TARGET_LOONGSON_2EF)
    return "<d>multu.g\t%0,%1,%2";
  else
    return "gs<d>multu\t%0,%1,%2";
}
  [(set_attr "type" "imul3nc")
   (set_attr "mode" "<MODE>")]
:}

abstract set_mult2_clobber extends sequence {
	root.1:=set_mult2; root.2:=clobber;
}

concrete mul<mode>3_mul3.insn instantiates set_mult2_clobber {
	root (register_operand:GPR:"=d,l",register_operand:GPR:"d,d",register_operand:GPR:"d,d",
		3=GPR:"=l,X"); root.1.2.mode:=GPR;
}
{:
  "ISA_HAS_<D>MUL3"
{
  if (which_alternative == 1)
    return "<d>mult\t%1,%2";
  if (<MODE>mode == SImode && TARGET_MIPS3900)
    return "mult\t%0,%1,%2";
  return "<d>mul\t%0,%1,%2";
}
  [(set_attr "type" "imul3,imul")
   (set_attr "mode" "<MODE>")]
:}

{:
;; If a register gets allocated to LO, and we spill to memory, the reload
;; will include a move from LO to a GPR.  Merge it into the multiplication
;; if it can set the GPR directly.
;;
;; Operand 0: LO
;; Operand 1: GPR (1st multiplication operand)
;; Operand 2: GPR (2nd multiplication operand)
;; Operand 3: GPR (destination)
:}

abstract parallel_set_mult2_clobber extends parallel {
	root.1:=set_mult2; root.2:=clobber;
}

abstract parallel_set_mult2_clobber_set extends sequence {
	root.1:=parallel_set_mult2_clobber; root.2:=set;
}

//concrete .peep2 instantiates.in parallel_set_mult2_clobber_set {
//	root ((lo_operand:SI:"", d_operand:SI:"", d_operand:SI:"", 3=SI:""), TODO: want NULL=SI:"" instead of 3=SI:""
//		(d_operand:SI:"", duplicate 0));
//	root.1.1.2.mode:=SI;
//}
//cmd_spec.in
//{:
//  "ISA_HAS_MUL3 && peep2_reg_dead_p (2, operands[0])"
//:}
//instantiates.out parallel_set_mult2_clobber {
//	root (duplicate 3, duplicate 1,duplicate 2, duplicate 0);
//	root.1.2.mode:=SI;
//}
//cmd_spec.out
//{:
//:}

{:
(define_peephole2
  [(parallel
       [(set (match_operand:SI 0 "lo_operand")
	     (mult:SI (match_operand:SI 1 "d_operand")
		      (match_operand:SI 2 "d_operand")))
        (clobber (scratch:SI))])
   (set (match_operand:SI 3 "d_operand")
	(match_dup 0))]
  "ISA_HAS_MUL3 && peep2_reg_dead_p (2, operands[0])"
  [(parallel
       [(set (match_dup 3)
	     (mult:SI (match_dup 1)
		      (match_dup 2)))
        (clobber (match_dup 0))])])
:}

concrete mul<mode>3_internal.insn overrides mul<mode>3.exp {
	root.1.predicate:=muldiv_target_operand; 
	allconstraints:= ("=l","d","d");
}
{:
  "!TARGET_FIX_R4000"
  "<d>mult\t%1,%2"
  [(set_attr "type" "imul")
   (set_attr "mode" "<MODE>")]
:}

concrete mul<mode>3_r4000.insn overrides mul<mode>3_mul3.insn {
	allconstraints:= ("=d","d","d","=l");
}
{:
  "TARGET_FIX_R4000"
  "<d>mult\t%1,%2\;mflo\t%0"
  [(set_attr "type" "imul")
   (set_attr "mode" "<MODE>")
   (set_attr "length" "8")]
:}

{:
;; On the VR4120 and VR4130, it is better to use "mtlo $0; macc" instead
;; of "mult; mflo".  They have the same latency, but the first form gives
;; us an extra cycle to compute the operands.

;; Operand 0: LO
;; Operand 1: GPR (1st multiplication operand)
;; Operand 2: GPR (2nd multiplication operand)
;; Operand 3: GPR (destination)
:}
abstract set_mult2_set extends sequence {
	root.1:=set_mult2; root.2:=set;
}
abstract set_plus2_mult1 extends set_plus2 {
	root.2.1:=mult;
}
abstract parallel_set_plus2_mult1_x2 extends parallel {
	root.1:=set_plus2_mult1; root.2:=set_plus2_mult1;
}
abstract set_parallel_set_plus2_mult1_x2 extends sequence {
	root.1:=set; root.2:=parallel_set_plus2_mult1_x2;
}
concrete .peep2 instantiates.in set_mult2_set {
	root (lo_operand:SI:"", d_operand:SI:"", d_operand:SI:"",
		d_operand:SI:"", duplicate 0); root.1.2.mode:=SI;
}
cmd_spec.in
{:
  "ISA_HAS_MACC && !ISA_HAS_MUL3"
:}
instantiates.out set_parallel_set_plus2_mult1_x2 {
	root (duplicate 0, const_int:0,(duplicate 0, duplicate 1,
	duplicate 2, duplicate 0, duplicate 3, duplicate 1, 
	duplicate 2, duplicate 0));
	root.2.1.2.mode:=SI;root.2.1.2.1.mode:=SI; 
	root.2.2.2.mode:=SI;root.2.2.2.1.mode:=SI; 
}
cmd_spec.out
{:
:}
{:
;; Multiply-accumulate patterns

;; This pattern is first matched by combine, which tries to use the
;; pattern wherever it can.  We don't know until later whether it
;; is actually profitable to use MADD over a "MUL; ADDIU" sequence,
;; so we need to keep both options open.
;;
;; The second alternative has a "?" marker because it is generally
;; one instruction more costly than the first alternative.  This "?"
;; marker is enough to convey the relative costs to the register
;; allocator.
;;
;; However, reload counts reloads of operands 4 and 5 in the same way as
;; reloads of the other operands, even though operands 4 and 5 need no
;; copy instructions.  Reload therefore thinks that the second alternative
;; is two reloads more costly than the first.  We add "*?*?" to the first
;; alternative as a counterweight.
:}

abstract set_plus2_mult1_clobber extends sequence {
	root.1:=set_plus2_mult1; root.2:=clobber;
}

abstract set_plus2_mult1_clobber_x2 extends sequence {
	root.1:=set_plus2_mult1; root.2:=clobber; root.3:=clobber;
}

concrete *mul_acc_si.insn instantiates set_plus2_mult1_clobber_x2 {
	root (register_operand:SI:"=l*?*?,d?", register_operand:SI:"d,d", 
	register_operand:SI:"d,d", register_operand:SI:"0,d", 4=SI:"=X,l", 5=SI:"=X,&d");
	root.1.2.mode:=SI; root.1.2.1.mode:=SI;
}
{:
  "GENERATE_MADD_MSUB && !TARGET_MIPS16"
  "@
    madd\t%1,%2
    #"
  [(set_attr "type"	"imadd")
   (set_attr "mode"	"SI")
   (set_attr "length"	"4,8")]
:}

{:
;; The same idea applies here.  The middle alternative needs one less
;; clobber than the final alternative, so we add "*?" as a counterweight.
:}

concrete *mul_acc_si_r3900.insn overrides *mul_acc_si.insn {
	allconstraints:=("=l*?*?,d*?,d?","d,d,d","d,d,d","0,l,d","=X,3,l","=X,X,&d");
}
{:
  "TARGET_MIPS3900 && !TARGET_MIPS16"
  "@
    madd\t%1,%2
    madd\t%0,%1,%2
    #"
  [(set_attr "type"	"imadd")
   (set_attr "mode"	"SI")
   (set_attr "length"	"4,4,8")]
:}

abstract parallel_set_mult2_clobber_set_plus2 extends parallel_set_mult2_clobber_set {
	root.2.2:=plus;
}

{:
;; Split *mul_acc_si if both the source and destination accumulator
;; values are GPRs.
:}
concrete .split instantiates.in set_plus2_mult1_clobber_x2 {
	root (d_operand:SI:"", d_operand:SI:"", d_operand:SI:"",d_operand:SI:"",
		lo_operand:SI:"", d_operand:SI:""); root.1.2.mode:=SI; root.1.2.1.mode:=SI;
}
cmd_spec.in
{:
  "reload_completed"
:}
instantiates.out parallel_set_mult2_clobber_set_plus2
{
	root ((duplicate 5, duplicate 1, duplicate 2, duplicate 4),
		duplicate 0, duplicate 5, duplicate 3); root.1.1.2.mode:=SI;
	root.2.2.mode:=SI;	
}
cmd_spec.out
{:
  ""
:}

concrete *macc.insn instantiates set_plus2_mult1_clobber {
	root (register_operand:SI:"=l,d", register_operand:SI:"d,d",
		register_operand:SI:"d,d", register_operand:SI:"0,l", 4=SI:"=X,3");
	root.1.2.mode:=SI; root.1.2.1.mode:=SI;
}
{:
  "ISA_HAS_MACC"
{
  if (which_alternative == 1)
    return "macc\t%0,%1,%2";
  else if (TARGET_MIPS5500)
    return "madd\t%1,%2";
  else
    /* The VR4130 assumes that there is a two-cycle latency between a macc
       that "writes" to $0 and an instruction that reads from it.  We avoid
       this by assigning to $1 instead.  */
    return "%[macc\t%@,%1,%2%]";
}
  [(set_attr "type" "imadd")
   (set_attr "mode" "SI")]
:}

abstract set_minus2_mult2_clobber extends sequence {
	root.1:=set_minus2;  root.1.2.2:=mult; root.2:=clobber;
}

concrete *msac.insn instantiates set_minus2_mult2_clobber {
	root (register_operand:SI:"=l,d",register_operand:SI:"0,l",
		register_operand:SI:"d,d",register_operand:SI:"d,d",4=SI:"=X,1");
	root.1.2.mode:=SI; root.1.2.2.mode:=SI;
}
{:
  "ISA_HAS_MSAC"
{
  if (which_alternative == 1)
    return "msac\t%0,%2,%3";
  else if (TARGET_MIPS5500)
    return "msub\t%2,%3";
  else
    return "msac\t$0,%2,%3";
}
  [(set_attr "type"     "imadd")
   (set_attr "mode"     "SI")]
:}

abstract set_minus2_mult2_clobber_x2 extends sequence {
	root.1:=set_minus2;  root.1.2.2:=mult; root.2:=clobber; root.3:=clobber;
}

abstract parallel_set_plus2_mult1_clobber extends parallel {
	root.1:=set_plus2; root.1.2.1:=mult; root.2:=clobber;	
}

abstract set_neg2_parallel_set_plus2_mult1_clobber extends sequence {
	root.1:=set_neg2; root.2:=parallel_set_plus2_mult1_clobber;
}
{:
;; An msac-like instruction implemented using negation and a macc.
:}
concrete *msac_using_macc.insn_and_split instantiates.in set_minus2_mult2_clobber_x2 {
	root (register_operand:SI:"=l,d", register_operand:SI:"0,l",register_operand:SI:"d,d",
		register_operand:SI:"d,d",4=SI:"=X,1",5=SI:"=d,d"); root.1.2.mode:=SI;
	root.1.2.2.mode:=SI;
}
cmd_spec.in
{:
  "ISA_HAS_MACC && !ISA_HAS_MSAC"
  "#"
  "&& reload_completed"
:}
instantiates.out set_neg2_parallel_set_plus2_mult1_clobber
{
	root (duplicate 5, duplicate 3, (duplicate 0, duplicate 2, duplicate 5,
	duplicate 1, duplicate 4)); root.1.2.mode:=SI; root.2.1.2.mode:=SI; root.2.1.2.1.mode:=SI;
}
cmd_spec.out
{:
  ""
  [(set_attr "type"     "imadd")
   (set_attr "length"	"8")]
:}
{:
;; Patterns generated by the define_peephole2 below.
:}

abstract set_plus2_mult1_set_plus2_mult1 extends sequence {
	root.1:=set_plus2_mult1; root.2:=set_plus2_mult1;
}

concrete *macc2.insn instantiates set_plus2_mult1_set_plus2_mult1 {
	root (muldiv_target_operand:SI:"=l", register_operand:SI:"d", register_operand:SI:"d",
		duplicate 0, register_operand:SI:"=d", duplicate 1, duplicate 2, duplicate 0);
	root.1.2.mode:=SI; root.1.2.1.mode:=SI; root.2.2.mode:=SI; root.2.2.1.mode:=SI;
}
{:
  "ISA_HAS_MACC && reload_completed"
  "macc\t%3,%1,%2"
  [(set_attr "type"	"imadd")
   (set_attr "mode"	"SI")]
:}

abstract set_minus2_mult2 extends set_minus2 {
	root.2.2:=mult;
}

abstract set_minus2_mult2_set_minus2_mult2 extends sequence {
	root.1:=set_minus2_mult2; root.2:=set_minus2_mult2;
}

concrete *msac2.insn instantiates set_minus2_mult2_set_minus2_mult2 {
	root (0=muldiv_target_operand:SI:"=l", duplicate 0, register_operand:SI:"d",
		register_operand:SI:"d", register_operand:SI:"=d", duplicate 0, duplicate 1, duplicate 2);
	root.1.2.mode:=SI; root.1.2.2.mode:=SI; root.2.2.mode:=SI; root.2.2.2.mode:=SI;
}
{:
  "ISA_HAS_MSAC && reload_completed"
  "msac\t%3,%1,%2"
  [(set_attr "type"	"imadd")
   (set_attr "mode"	"SI")]
:}

{:
;; Convert macc $0,<r1>,<r2> & mflo <r3> into macc <r3>,<r1>,<r2>
;; Similarly msac.
;;
;; Operand 0: LO
;; Operand 1: macc/msac
;; Operand 2: GPR (destination)
:}
abstract parallel_set_clobber extends parallel {
	root.1:=set; root.2:=clobber;
}

abstract parallel_set_clobber_set extends sequence {
	root.1:=parallel_set_clobber; root.2:=set;
}

{:
(define_peephole2
  [(parallel
       [(set (match_operand:SI 0 "lo_operand")
	     (match_operand:SI 1 "macc_msac_operand"))
	(clobber (scratch:SI))])
   (set (match_operand:SI 2 "d_operand")
	(match_dup 0))]
  ""
  [(parallel [(set (match_dup 0)
		   (match_dup 1))
	      (set (match_dup 2)
		   (match_dup 1))])])

;; When we have a three-address multiplication instruction, it should
;; be faster to do a separate multiply and add, rather than moving
;; something into LO in order to use a macc instruction.
;;
;; This peephole needs a scratch register to cater for the case when one
;; of the multiplication operands is the same as the destination.
;;
;; Operand 0: GPR (scratch)
;; Operand 1: LO
;; Operand 2: GPR (addend)
;; Operand 3: GPR (destination)
;; Operand 4: macc/msac
;; Operand 5: new multiplication
;; Operand 6: new addition/subtraction
(define_peephole2
  [(match_scratch:SI 0 "d")
   (set (match_operand:SI 1 "lo_operand")
	(match_operand:SI 2 "d_operand"))
   (match_dup 0)
   (parallel
       [(set (match_operand:SI 3 "d_operand")
	     (match_operand:SI 4 "macc_msac_operand"))
	(clobber (match_dup 1))])]
  "ISA_HAS_MUL3 && peep2_reg_dead_p (2, operands[1])"
  [(parallel [(set (match_dup 0)
		   (match_dup 5))
	      (clobber (match_dup 1))])
   (set (match_dup 3)
	(match_dup 6))]
{
  operands[5] = XEXP (operands[4], GET_CODE (operands[4]) == PLUS ? 0 : 1);
  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[4]), SImode,
				operands[2], operands[0]);
})

;; Same as above, except LO is the initial target of the macc.
;;
;; Operand 0: GPR (scratch)
;; Operand 1: LO
;; Operand 2: GPR (addend)
;; Operand 3: macc/msac
;; Operand 4: GPR (destination)
;; Operand 5: new multiplication
;; Operand 6: new addition/subtraction
(define_peephole2
  [(match_scratch:SI 0 "d")
   (set (match_operand:SI 1 "lo_operand")
	(match_operand:SI 2 "d_operand"))
   (match_dup 0)
   (parallel
       [(set (match_dup 1)
	     (match_operand:SI 3 "macc_msac_operand"))
	(clobber (scratch:SI))])
   (match_dup 0)
   (set (match_operand:SI 4 "d_operand")
	(match_dup 1))]
  "ISA_HAS_MUL3 && peep2_reg_dead_p (3, operands[1])"
  [(parallel [(set (match_dup 0)
		   (match_dup 5))
	      (clobber (match_dup 1))])
   (set (match_dup 4)
	(match_dup 6))]
{
  operands[5] = XEXP (operands[3], GET_CODE (operands[3]) == PLUS ? 0 : 1);
  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[3]), SImode,
				operands[2], operands[0]);
})

;; See the comment above *mul_add_si for details.
:}
concrete *mul_sub_si.insn instantiates set_minus2_mult2_clobber_x2 {
	root (register_operand:SI:"=l*?*?,d?", register_operand:SI:"0,d", register_operand:SI:"d,d",
		register_operand:SI:"d,d",4=SI:"=X,l",5=SI:"=X,&d");
	root.1.2.mode:=SI; root.1.2.2.mode:=SI;
}
{:
  "GENERATE_MADD_MSUB"
  "@
   msub\t%2,%3
   #"
  [(set_attr "type"     "imadd")
   (set_attr "mode"     "SI")
   (set_attr "length"   "4,8")]
:}
{:
;; Split *mul_sub_si if both the source and destination accumulator
;; values are GPRs.
:}

abstract parallel_set_mult2_clobber_set_minus2 extends sequence {
	root.1:=parallel_set_mult2_clobber;
	root.2:=set_minus2;
}

concrete .split instantiates.in set_minus2_mult2_clobber_x2 {
	root (d_operand:SI:"", d_operand:SI:"", d_operand:SI:"",d_operand:SI:"",
		lo_operand:SI:"", d_operand:SI:""); root.1.2.mode:=SI; root.1.2.2.mode:=SI;
}
cmd_spec.in
{:
  "reload_completed"
:}
instantiates.out parallel_set_mult2_clobber_set_minus2 {
	root ((duplicate 5, duplicate 2, duplicate 3, duplicate 4), duplicate 0,
		duplicate 1, duplicate 5); root.1.1.2.mode:=SI; root.2.2.mode:=SI;
}
cmd_spec.out
{:
	""
:}

abstract set_neg2_mult extends set_neg2 {
	root.2.1:=mult;
}

abstract set_neg2_mult_clobber extends sequence {
	root.1:=set_neg2_mult; root.2:=clobber;
}

concrete *muls.insn instantiates set_neg2_mult_clobber {
	root (register_operand:SI:"=l,d", register_operand:SI:"d,d",register_operand:SI:"d,d",
		3=SI:"=X,l"); root.1.2.mode:=SI; root.1.2.1.mode:=SI;
}
{:
  "ISA_HAS_MULS"
  "@
   muls\t$0,%1,%2
   muls\t%0,%1,%2"
  [(set_attr "type"     "imul,imul3")
   (set_attr "mode"     "SI")]
:}

abstract set_mult2_any_extend1_any_extend2 extends set_mult2 {
	root.2.1:=any_extend; root.2.2:=any_extend;
}

concrete <u>mulsidi3.exp instantiates set_mult2_any_extend1_any_extend2 {
	root (register_operand:DI:"", register_operand:SI:"",register_operand:SI:"");
	root.2.mode:=DI; root.2.1.mode:=DI; root.2.2.mode:=DI;
}
{:
  "mips_mulsidi3_gen_fn (<CODE>) != NULL"
{
  mulsidi3_gen_fn fn = mips_mulsidi3_gen_fn (<CODE>);
  emit_insn (fn (operands[0], operands[1], operands[2]));
  DONE;
}
:}

concrete <u>mulsidi3_32bit_mips16.exp overrides <u>mulsidi3.exp {
	root.2.mode:=DI;
}
{:
  "!TARGET_64BIT && TARGET_MIPS16"
{
  rtx hilo;

  hilo = gen_rtx_REG (DImode, MD_REG_FIRST);
  emit_insn (gen_<u>mulsidi3_32bit (hilo, operands[1], operands[2]));
  emit_move_insn (operands[0], hilo);
  DONE;
}
:}
{:
;; As well as being named patterns, these instructions are used by the
;; __builtin_mips_mult<u>() functions.  We must always make those functions
;; available if !TARGET_64BIT && ISA_HAS_DSP.
:}

concrete <u>mulsidi3_32bit.insn overrides <u>mulsidi3.exp {
	allconstraints:=("=ka","d","d"); 	root.1.predicate:=muldiv_target_operand; 	root.2.mode:=DI;
}
{:
  "!TARGET_64BIT && (!TARGET_FIX_R4000 || ISA_HAS_DSP)"
{
  if (ISA_HAS_DSP_MULT)
    return "mult<u>\t%q0,%1,%2";
  else
    return "mult<u>\t%1,%2";
}
  [(set_attr "type" "imul")
   (set_attr "mode" "SI")]
:}

abstract set_mult2_any_extend1_any_extend2_clobber extends sequence {
	root.1:=set_mult2_any_extend1_any_extend2; root.2:=clobber;
} 

concrete <u>mulsidi3_32bit_r4000.insn instantiates set_mult2_any_extend1_any_extend2_clobber {
	root (register_operand:DI:"=d", register_operand:SI:"d", register_operand:SI:"d",
		3=DI:"=x"); root.1.2.mode:=DI; root.1.2.1.mode:=DI; root.1.2.2.mode:=DI;
}
{:
  "!TARGET_64BIT && TARGET_FIX_R4000 && !ISA_HAS_DSP"
  "mult<u>\t%1,%2\;mflo\t%L0\;mfhi\t%M0"
  [(set_attr "type" "imul")
   (set_attr "mode" "SI")
   (set_attr "length" "12")]
:}

abstract set_mult2_any_extend1_any_extend2_clobber_x2 extends sequence {
	root.1:=set_mult2_any_extend1_any_extend2; root.2:=clobber; root.3:=clobber;
}

concrete <u>mulsidi3_64bit.insn_and_split instantiates.in set_mult2_any_extend1_any_extend2_clobber_x2 {
	root (register_operand:DI:"=d", register_operand:SI:"d", register_operand:SI:"d",
	3=TI:"=x", 4=DI:"=d"); root.1.2.mode:=DI; root.1.2.1.mode:=DI; root.1.2.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_64BIT && !TARGET_FIX_R4000 && !ISA_HAS_DMUL3 && !TARGET_MIPS16"
  "#"
  "&& reload_completed"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  emit_insn (gen_<u>mulsidi3_64bit_split (operands[0], operands[1],
					  operands[2], operands[4]));
  DONE;
}
  [(set_attr "type" "imul")
   (set_attr "mode" "SI")
   (set (attr "length")
	(if_then_else (match_test "ISA_HAS_EXT_INS")
		      (const_int 16)
		      (const_int 28)))]
:}

concrete <u>mulsidi3_64bit_mips16.exp overrides <u>mulsidi3.exp {
	root.2.mode:=DI;
}
{:
  "TARGET_64BIT && TARGET_MIPS16"
{
  emit_insn (gen_<u>mulsidi3_64bit_split (operands[0], operands[1],
					  operands[2], gen_reg_rtx (DImode)));
  DONE;
}
:}

concrete <u>mulsidi3_64bit_split.exp overrides <u>mulsidi3_32bit_r4000.insn {
	allconstraints:=("","","","");
	root.2.1:=register_operand:DI:"";
}
{:
  ""
{
  rtx hilo;

  hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
  emit_insn (gen_<u>mulsidi3_64bit_hilo (hilo, operands[1], operands[2]));

  emit_move_insn (operands[0], gen_rtx_REG (DImode, LO_REGNUM));
  emit_insn (gen_mfhidi_ti (operands[3], hilo));

  if (ISA_HAS_EXT_INS)
    emit_insn (gen_insvdi (operands[0], GEN_INT (32), GEN_INT (32),
			   operands[3]));
  else
    {
      /* Zero-extend the low part.  */
      mips_emit_binary (ASHIFT, operands[0], operands[0], GEN_INT (32));
      mips_emit_binary (LSHIFTRT, operands[0], operands[0], GEN_INT (32));

      /* Shift the high part into place.  */
      mips_emit_binary (ASHIFT, operands[3], operands[3], GEN_INT (32));

      /* OR the two halves together.  */
      mips_emit_binary (IOR, operands[0], operands[0], operands[3]);
    }
  DONE;
}
:}

abstract set_unspec2_mult1_any_extend1_any_extend2 extends set_unspec2 {
	root.2.1:=mult; root.2.1.1:=any_extend; root.2.1.2:=any_extend;
}

concrete <u>mulsidi3_64bit_hilo.insn instantiates set_unspec2_mult1_any_extend1_any_extend2
{
	root (muldiv_target_operand:TI:"=x",(register_operand:SI:"d", register_operand:SI:"d", 
		<UNSPEC_SET_HILO>)); root.2.mode:=TI;root.2.1.mode:=DI;root.2.1.1.mode:=DI; root.2.1.2.mode:=DI;
}
{:
  "TARGET_64BIT && !TARGET_FIX_R4000"
  "mult<u>\t%1,%2"
  [(set_attr "type" "imul")
   (set_attr "mode" "SI")]
:}

abstract set_mult2_sign_extend1_sign_extend2 extends set_mult2 {
	root.2.1:=sign_extend; root.2.2:=sign_extend;
}

abstract set_mult2_sign_extend1_sign_extend2_clobber extends sequence {
	root.1:=set_mult2_sign_extend1_sign_extend2; root.2:=clobber;
}
{:
;; See comment before the ISA_HAS_DMUL3 case in mips_mulsidi3_gen_fn.
:}
concrete mulsidi3_64bit_dmul.insn instantiates set_mult2_sign_extend1_sign_extend2_clobber {
	root (register_operand:DI:"=d", register_operand:SI:"d",register_operand:SI:"d", 3=DI:"=l");
	root.1.2.mode:=DI; root.1.2.1.mode:=DI; root.1.2.2.mode:=DI;	
}
{:
  "TARGET_64BIT && ISA_HAS_DMUL3"
  "dmul\t%0,%1,%2"
  [(set_attr "type" "imul3")
   (set_attr "mode" "DI")]
:}
{:
;; Widening multiply with negation.
:}

abstract set_neg2_mult_any_extend1_any_extend2 extends set_neg2_mult {
	root.2.1.1:=any_extend; root.2.1.2:=any_extend;
}

concrete *muls<u>_di.insn instantiates set_neg2_mult_any_extend1_any_extend2 {
	root (muldiv_target_operand:DI:"=x", register_operand:SI:"d", register_operand:SI:"d");
	root.2.mode:=DI; root.2.1.mode:=DI; root.2.1.1.mode:=DI; root.2.1.2.mode:=DI;	
}
{:
  "!TARGET_64BIT && ISA_HAS_MULS"
  "muls<u>\t$0,%1,%2"
  [(set_attr "type" "imul")
   (set_attr "mode" "SI")]
:}
{:
;; As well as being named patterns, these instructions are used by the
;; __builtin_mips_msub<u>() functions.  We must always make those functions
;; available if !TARGET_64BIT && ISA_HAS_DSP.
;;
;; This leads to a slight inconsistency.  We honor any tuning overrides
;; in GENERATE_MADD_MSUB for -mno-dsp, but always ignore them for -mdsp,
;; even if !ISA_HAS_DSP_MULT.
:}
abstract set_minus2_mult2_any_extend1_any_extend2 extends set_minus2 {
	root.2.2:=mult; root.2.2.1:=any_extend; root.2.2.2:=any_extend;
}

concrete <u>msubsidi4.insn instantiates set_minus2_mult2_any_extend1_any_extend2 {
	root (0=muldiv_target_operand:DI:"=ka",3=muldiv_target_operand:DI:"0", 1=register_operand:SI:"d",
		2=register_operand:SI:"d"); root.2.mode:=DI; root.2.2.mode:=DI;
	root.2.2.1.mode:=DI; root.2.2.2.mode:=DI;
}
{:
  "!TARGET_64BIT && (ISA_HAS_MSAC || GENERATE_MADD_MSUB || ISA_HAS_DSP)"
{
  if (ISA_HAS_DSP_MULT)
    return "msub<u>\t%q0,%1,%2";
  else if (TARGET_MIPS5500 || GENERATE_MADD_MSUB)
    return "msub<u>\t%1,%2";
  else
    return "msac<u>\t$0,%1,%2";
}
  [(set_attr "type" "imadd")
   (set_attr "mode" "SI")]
:}
{:
;; _highpart patterns
:}

abstract set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2 extends set_truncate2 {
	root.2.1:=lshiftrt; root.2.1.1:=mult; root.2.1.1.1:=any_extend; root.2.1.1.2:=any_extend;
}

concrete <su>mulsi3_highpart.exp instantiates set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2 {
	root (register_operand:SI:"", register_operand:SI:"", register_operand:SI:"", const_int:32);
	root.2.mode:=SI; root.2.1.mode:=DI; root.2.1.1.mode:=DI; root.2.1.1.1.mode:=DI; root.2.1.1.2.mode:=DI;
}
{:
  ""
{
  if (ISA_HAS_MULHI)
    emit_insn (gen_<su>mulsi3_highpart_mulhi_internal (operands[0],
						       operands[1],
						       operands[2]));
  else if (TARGET_MIPS16)
    emit_insn (gen_<su>mulsi3_highpart_split (operands[0], operands[1],
					      operands[2]));
  else
    emit_insn (gen_<su>mulsi3_highpart_internal (operands[0], operands[1],
					         operands[2]));
  DONE;
}
:}

abstract set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2_clobber extends sequence {
	root.1:=set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2;
	root.2:=clobber;
}

concrete <su>mulsi3_highpart_internal.insn_and_split instantiates.in set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2_clobber {
	root (register_operand:SI:"=d", register_operand:SI:"d", register_operand:SI:"d", const_int:32, 3=SI:"=l");
	root.1.2.mode:=SI; root.1.2.1.mode:=DI; root.1.2.1.1.mode:=DI; root.1.2.1.1.1.mode:=DI; root.1.2.1.1.2.mode:=DI;
}
cmd_spec.in
{:
  "!ISA_HAS_MULHI && !TARGET_MIPS16"
  { return TARGET_FIX_R4000 ? "mult<u>\t%1,%2\n\tmfhi\t%0" : "#"; }
  "&& reload_completed && !TARGET_FIX_R4000"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  emit_insn (gen_<su>mulsi3_highpart_split (operands[0], operands[1],
					    operands[2]));
  DONE;
}
  [(set_attr "type" "imul")
   (set_attr "mode" "SI")
   (set_attr "length" "8")]
:}

concrete <su>mulsi3_highpart_split.exp overrides <su>mulsi3_highpart.exp
{
	root.2.mode:=SI;
}
{:
  ""
{
  rtx hilo;

  if (TARGET_64BIT)
    {
      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
      emit_insn (gen_<u>mulsidi3_64bit_hilo (hilo, operands[1], operands[2]));
      emit_insn (gen_mfhisi_ti (operands[0], hilo));
    }
  else
    {
      hilo = gen_rtx_REG (DImode, MD_REG_FIRST);
      emit_insn (gen_<u>mulsidi3_32bit (hilo, operands[1], operands[2]));
      emit_insn (gen_mfhisi_di (operands[0], hilo));
    }
  DONE;
}
:}

concrete <su>mulsi3_highpart_mulhi_internal.insn instantiates 
set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2_clobber {
	root (register_operand:SI:"=d", register_operand:SI:"d", 
		register_operand:SI:"d", const_int:32,3=SI:"=l");
	root.1.2.mode:=SI; root.1.2.1.mode:=DI; root.1.2.1.1.mode:=DI; 
	root.1.2.1.1.1.mode:=DI; root.1.2.1.1.2.mode:=DI;
}
{:
  "ISA_HAS_MULHI"
  "mulhi<u>\t%0,%1,%2"
  [(set_attr "type" "imul3")
   (set_attr "mode" "SI")]
:}

abstract set_truncate2_lshiftrt1_neg1_mult1_any_extend1_any_extend2 extends set_truncate2
{
	root.2.1:=lshiftrt;	root.2.1.1:=neg; root.2.1.1.1:=mult; 
	root.2.1.1.1.1:=any_extend; root.2.1.1.1.2:=any_extend;
}

abstract set_truncate2_lshiftrt1_neg1_mult1_any_extend1_any_extend2_clobber 
extends sequence {
	root.1:=set_truncate2_lshiftrt1_neg1_mult1_any_extend1_any_extend2;
	root.2:=clobber;
}

concrete *<su>mulsi3_highpart_neg_mulhi_internal.insn instantiates 
set_truncate2_lshiftrt1_neg1_mult1_any_extend1_any_extend2_clobber {
	root (register_operand:SI:"=d", register_operand:SI:"d", register_operand:SI:"d",
		const_int:32, 3=SI:"=l");
	root.1.2.mode:=SI; root.1.2.1.mode:=DI; root.1.2.1.1.mode:=DI;
	root.1.2.1.1.1.mode:=DI; root.1.2.1.1.1.1.mode:=DI; root.1.2.1.1.1.2.mode:=DI;
}
{:
  "ISA_HAS_MULHI"
  "mulshi<u>\t%0,%1,%2"
  [(set_attr "type" "imul3")
   (set_attr "mode" "SI")]
:}
{:
;; Disable unsigned multiplication for -mfix-vr4120.  This is for VR4120
;; errata MD(0), which says that dmultu does not always produce the
;; correct result.
:}

concrete <su>muldi3_highpart.exp instantiates 
set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2 {
	root (register_operand:DI:"", register_operand:DI:"", register_operand:DI:"",
	const_int:64);
	root.2.mode:=DI; root.2.1.mode:=TI; root.2.1.1.mode:=TI; root.2.1.1.1.mode:=TI;
	root.2.1.1.2.mode:=TI;
}
{:
  "TARGET_64BIT && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)"
{
  if (TARGET_MIPS16)
    emit_insn (gen_<su>muldi3_highpart_split (operands[0], operands[1],
					      operands[2]));
  else
    emit_insn (gen_<su>muldi3_highpart_internal (operands[0], operands[1],
						 operands[2]));
  DONE;
}
:}

concrete <su>muldi3_highpart_internal.insn_and_split instantiates.in
set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2_clobber {
	root (register_operand:DI:"=d", register_operand:DI:"d", register_operand:DI:"d",
		const_int:64, 3=DI:"=l");
	root.1.2.mode:=DI; root.1.2.1.mode:=TI; root.1.2.1.1.mode:=TI; root.1.2.1.1.1.mode:=TI;
	root.1.2.1.1.2.mode:=TI;
}
cmd_spec.in
{:
  "TARGET_64BIT
   && !TARGET_MIPS16
   && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)"
  { return TARGET_FIX_R4000 ? "dmult<u>\t%1,%2\n\tmfhi\t%0" : "#"; }
  "&& reload_completed && !TARGET_FIX_R4000"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  emit_insn (gen_<su>muldi3_highpart_split (operands[0], operands[1],
					    operands[2]));
  DONE;
}
  [(set_attr "type" "imul")
   (set_attr "mode" "DI")
   (set_attr "length" "8")]
:}

concrete <su>muldi3_highpart_split.exp instantiates
set_truncate2_lshiftrt1_mult1_any_extend1_any_extend2 {
	root (register_operand:DI:"", register_operand:DI:"", 
		register_operand:DI:"", const_int:64);
	root.2.mode:=DI; root.2.1.mode:=TI; root.2.1.1.mode:=TI;
	root.2.1.1.1.mode:=TI; root.2.1.1.2.mode:=TI;
}
{:
  ""
{
  rtx hilo;

  hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
  emit_insn (gen_<u>mulditi3_internal (hilo, operands[1], operands[2]));
  emit_insn (gen_mfhidi_ti (operands[0], hilo));
  DONE;
}
:}
concrete <u>mulditi3.exp overrides <u>mulsidi3.exp {
	root.1.mode:=TI; root.2.mode:=TI; root.2.1.mode:=TI; root.2.1.1.mode:=DI;
	root.2.2.mode:=TI; root.2.2.1.mode:=DI;
}
{:
  "TARGET_64BIT && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)"
{
  rtx hilo;

  if (TARGET_MIPS16)
    {
      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
      emit_insn (gen_<u>mulditi3_internal (hilo, operands[1], operands[2]));
      emit_move_insn (operands[0], hilo);
    }
  else if (TARGET_FIX_R4000)
    emit_insn (gen_<u>mulditi3_r4000 (operands[0], operands[1], operands[2]));
  else
    emit_insn (gen_<u>mulditi3_internal (operands[0], operands[1],
					 operands[2]));
  DONE;
}
:}

concrete <u>mulditi3_internal.insn overrides <u>mulsidi3.exp {
	root.1.mode:=TI; root.2.mode:=TI; root.2.1.mode:=TI; root.2.1.1.mode:=DI;
	root.2.2.mode:=TI; root.2.2.1.mode:=DI; root.1.predicate:=muldiv_target_operand;
	allconstraints:=("=x","d","d");
}
{:
  "TARGET_64BIT
   && !TARGET_FIX_R4000
   && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)"
  "dmult<u>\t%1,%2"
  [(set_attr "type" "imul")
   (set_attr "mode" "DI")]
:}

concrete <u>mulditi3_r4000.insn overrides <u>mulsidi3_32bit_r4000.insn {
	root.1.1.mode:=TI; root.1.2.mode:=TI; root.1.2.1.mode:=TI; root.1.2.1.1.mode:=DI;
	root.1.2.2.mode:=TI; root.1.2.2.1.mode:=DI; root.1.2.1.mode:=TI; root.2.1.mode:=TI;
}
{:
  "TARGET_64BIT
   && TARGET_FIX_R4000
   && !(<CODE> == ZERO_EXTEND && TARGET_FIX_VR4120)"
  "dmult<u>\t%1,%2\;mflo\t%L0\;mfhi\t%M0"
  [(set_attr "type" "imul")
   (set_attr "mode" "DI")
   (set_attr "length" "12")]
:}
{:
;; The R4650 supports a 32-bit multiply/ 64-bit accumulate
;; instruction.  The HI/LO registers are used as a 64-bit accumulator.
:}

concrete madsi.insn instantiates set_plus2_mult1 {
	root (register_operand:SI:"+l", register_operand:SI:"d",
		register_operand:SI:"d", duplicate 0);
	root.2.mode:=SI; root.2.1.mode:=SI;
}
{:
  "TARGET_MAD"
  "mad\t%1,%2"
  [(set_attr "type"	"imadd")
   (set_attr "mode"	"SI")]
:}
{:
;; See the comment above <u>msubsidi4 for the relationship between
;; ISA_HAS_DSP and ISA_HAS_DSP_MULT.
:}

abstract set_plus2_mult1_any_extend1_any_extend2 extends set_plus2_mult1 {
	root.2.1.1:=any_extend; root.2.1.2:=any_extend;
}

concrete <u>maddsidi4.insn instantiates set_plus2_mult1_any_extend1_any_extend2 {
	root (muldiv_target_operand:DI:"=ka", register_operand:SI:"d", register_operand:SI:"d",
		muldiv_target_operand:DI:"0"); root.2.mode:=DI; root.2.1.mode:=DI;
	root.2.1.1.mode:=DI; root.2.1.2.mode:=DI;
}
{:
  "(TARGET_MAD || ISA_HAS_MACC || GENERATE_MADD_MSUB || ISA_HAS_DSP)
   && !TARGET_64BIT"
{
  if (TARGET_MAD)
    return "mad<u>\t%1,%2";
  else if (ISA_HAS_DSP_MULT)
    return "madd<u>\t%q0,%1,%2";
  else if (GENERATE_MADD_MSUB || TARGET_MIPS5500)
    return "madd<u>\t%1,%2";
  else
    /* See comment in *macc.  */
    return "%[macc<u>\t%@,%1,%2%]";
}
  [(set_attr "type" "imadd")
   (set_attr "mode" "SI")]
:}

{:
;; Floating point multiply accumulate instructions.
:}

concrete *madd4<mode>.insn instantiates set_plus2_mult1 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f",
		register_operand:ANYF:"f", register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.1.mode:=ANYF;
}
{:
  "ISA_HAS_FP_MADD4_MSUB4 && TARGET_FUSED_MADD"
  "madd.<fmt>\t%0,%3,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete *madd3<mode>.insn overrides *madd4<mode>.insn {
	allconstraints:= ("=f","f","f","0");
}
{:
  "ISA_HAS_FP_MADD3_MSUB3 && TARGET_FUSED_MADD"
  "madd.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

abstract set_minus2_mult1 extends set_minus2 {
	root.2.1:=mult;
}

concrete *msub4<mode>.insn instantiates set_minus2_mult1 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f",
		register_operand:ANYF:"f", register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.1.mode:=ANYF;
}
{:
  "ISA_HAS_FP_MADD4_MSUB4 && TARGET_FUSED_MADD"
  "msub.<fmt>\t%0,%3,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete *msub3<mode>.insn overrides *msub4<mode>.insn {
	root.2.2.constraint:="0";
}
{:
 "ISA_HAS_FP_MADD3_MSUB3 && TARGET_FUSED_MADD"
  "msub.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

abstract set_neg2_plus1_mult1 extends set_neg2 {
	root.2.1:=plus; root.2.1.1:=mult;
}

concrete *nmadd4<mode>.insn instantiates set_neg2_plus1_mult1 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f",
		register_operand:ANYF:"f", register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.1.mode:=ANYF; root.2.1.1.mode:=ANYF;
}
{:
  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
   && TARGET_FUSED_MADD
   && HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmadd.<fmt>\t%0,%3,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete *nmadd3<mode>.insn overrides *nmadd4<mode>.insn {
	root.2.1.2.constraint:="0";
}
{:
  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
   && TARGET_FUSED_MADD
   && HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmadd.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

abstract set_minus2_mult1_neg1 extends set_minus2_mult1 {
	root.2.1.1:=neg;
}

concrete *nmadd4<mode>_fastmath.insn instantiates set_minus2_mult1_neg1 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f", register_operand:ANYF:"f",
		register_operand:ANYF:"f"); root.2.mode:=ANYF; root.2.1.mode:=ANYF;
	root.2.1.1.mode:=ANYF;
}
{:
  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
   && TARGET_FUSED_MADD
   && !HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmadd.<fmt>\t%0,%3,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete *nmadd3<mode>_fastmath.insn overrides *nmadd4<mode>_fastmath.insn {
	root.2.2.constraint:="0";
}
{:
  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
   && TARGET_FUSED_MADD
   && !HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmadd.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

abstract set_neg2_minus1 extends set_neg2{
	root.2.1:=minus;
}

abstract set_neg2_minus1_mult1 extends set_neg2_minus1 {
	root.2.1.1:=mult;
}

concrete *nmsub4<mode>.insn instantiates set_neg2_minus1_mult1 {
	root (0=register_operand:ANYF:"=f", 2=register_operand:ANYF:"f",
		3=register_operand:ANYF:"f", 1=register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.1.mode:=ANYF; root.2.1.1.mode:=ANYF;
}
{:
  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
   && TARGET_FUSED_MADD
   && HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmsub.<fmt>\t%0,%1,%2,%3"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete *nmsub3<mode>.insn overrides *nmsub4<mode>.insn {
	root.2.1.2.constraint:="0";
}
{:
  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
   && TARGET_FUSED_MADD
   && HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmsub.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}



concrete *nmsub4<mode>_fastmath.insn instantiates set_minus2_mult2 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f",
		register_operand:ANYF:"f", register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.2.mode:=ANYF;
}
{:
  "ISA_HAS_NMADD4_NMSUB4 (<MODE>mode)
   && TARGET_FUSED_MADD
   && !HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmsub.<fmt>\t%0,%1,%2,%3"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete *nmsub3<mode>_fastmath.insn overrides *nmsub4<mode>_fastmath.insn {
	root.2.2.2.constraint:="0";
}
{:
  "ISA_HAS_NMADD3_NMSUB3 (<MODE>mode)
   && TARGET_FUSED_MADD
   && !HONOR_SIGNED_ZEROS (<MODE>mode)
   && !HONOR_NANS (<MODE>mode)"
  "nmsub.<fmt>\t%0,%1,%2"
  [(set_attr "type" "fmadd")
   (set_attr "mode" "<UNITMODE>")]
:}
{:
;;
;;  ....................
;;
;;	DIVISION and REMAINDER
;;
;;  ....................
;;
:}

concrete div<mode>3.exp instantiates set_div2 {
	root (register_operand:ANYF:"", reg_or_1_operand:ANYF:"", register_operand:ANYF:"");
	root.2.mode:=ANYF;
}
{:
  "<divide_condition>"
{
  if (const_1_operand (operands[1], <MODE>mode))
    if (!(<recip_condition> && flag_unsafe_math_optimizations))
      operands[1] = force_reg (<MODE>mode, operands[1]);
}
:}

{:
;; These patterns work around the early SB-1 rev2 core "F1" erratum:
;;
;; If an mfc1 or dmfc1 happens to access the floating point register
;; file at the same time a long latency operation (div, sqrt, recip,
;; sqrt) iterates an intermediate result back through the floating
;; point register file bypass, then instead returning the correct
;; register value the mfc1 or dmfc1 operation returns the intermediate
;; result of the long latency operation.
;;
;; The workaround is to insert an unconditional 'mov' from/to the
;; long latency op destination register.
:}

concrete *div<mode>3.insn overrides div<mode>3.exp {
	root.2.1.predicate:=register_operand;
	allconstraints:=("=f","f","f");
}
{:
  "<divide_condition>"
{
  if (TARGET_FIX_SB1)
    return "div.<fmt>\t%0,%1,%2\;mov.<fmt>\t%0,%0";
  else
    return "div.<fmt>\t%0,%1,%2";
}
  [(set_attr "type" "fdiv")
   (set_attr "mode" "<UNITMODE>")
   (set (attr "length")
        (if_then_else (match_test "TARGET_FIX_SB1")
                      (const_int 8)
                      (const_int 4)))]
:}
concrete *recip<mode>3.insn overrides div<mode>3.exp {
	root.2.1.predicate:=const_1_operand; allconstraints:=("=f","","f");
}
{:
  "<recip_condition> && flag_unsafe_math_optimizations"
{
  if (TARGET_FIX_SB1)
    return "recip.<fmt>\t%0,%2\;mov.<fmt>\t%0,%0";
  else
    return "recip.<fmt>\t%0,%2";
}
  [(set_attr "type" "frdiv")
   (set_attr "mode" "<UNITMODE>")
   (set (attr "length")
        (if_then_else (match_test "TARGET_FIX_SB1")
                      (const_int 8)
                      (const_int 4)))]
:}

{:
;; VR4120 errata MD(A1): signed division instructions do not work correctly
;; with negative operands.  We use special libgcc functions instead.
:}

abstract set_div2_set_mod2 extends sequence {
	root.1:=set_div2; root.2:=set_mod2;
}

concrete divmod<mode>4.exp instantiates set_div2_set_mod2 {
	root (register_operand:GPR:"", register_operand:GPR:"", register_operand:GPR:"",
		register_operand:GPR:"", duplicate 1, duplicate 2);
	root.1.2.mode:=GPR; root.2.2.mode:=GPR;
}
{:
  "!TARGET_FIX_VR4120"
{
  if (TARGET_MIPS16)
    {
      emit_insn (gen_divmod<mode>4_split (operands[3], operands[1],
					  operands[2]));
      emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, LO_REGNUM));
    }
  else
    emit_insn (gen_divmod<mode>4_internal (operands[0], operands[1],
					   operands[2], operands[3]));
  DONE;
}
:}

concrete divmod<mode>4_internal.insn_and_split instantiates.in set_div2_set_mod2 {
	root (muldiv_target_operand:GPR:"=l", register_operand:GPR:"d",
		register_operand:GPR:"d",register_operand:GPR:"=d",
		duplicate 1, duplicate 2); root.1.2.mode:=GPR; root.2.2.mode:=GPR;
}
cmd_spec.in
{:
  "!TARGET_FIX_VR4120 && !TARGET_MIPS16"
  "#"
  "&& reload_completed"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  emit_insn (gen_divmod<mode>4_split (operands[3], operands[1], operands[2]));
  DONE;
}
 [(set_attr "type" "idiv")
  (set_attr "mode" "<MODE>")
  (set_attr "length" "8")]
:}

abstract set_udiv2_set_umod2 extends sequence {
	root.1:=set_udiv2; root.2:=set_umod2;
}

concrete udivmod<mode>4.exp instantiates set_udiv2_set_umod2 {
	root (register_operand:GPR:"", register_operand:GPR:"",register_operand:GPR:"",
		register_operand:GPR:"", duplicate 1,duplicate 2);
	root.1.2.mode:=GPR; root.2.2.mode:=GPR;
}
{: 
 ""
{
  if (TARGET_MIPS16)
    {
      emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1],
					   operands[2]));
      emit_move_insn (operands[0], gen_rtx_REG (<MODE>mode, LO_REGNUM));
    }
  else
    emit_insn (gen_udivmod<mode>4_internal (operands[0], operands[1],
					    operands[2], operands[3]));
  DONE;
}
:}

concrete udivmod<mode>4_internal.insn_and_split instantiates.in set_udiv2_set_umod2 {
	root (muldiv_target_operand:GPR:"=l", register_operand:GPR:"d",
		register_operand:GPR:"d", register_operand:GPR:"=d", duplicate 1,
		duplicate 2); root.1.2.mode:=GPR; root.2.2.mode:=GPR;
}
cmd_spec.in
{:
  "!TARGET_MIPS16"
  "#"
  "reload_completed"
:}
instantiates.out sequence {
  root (const_int:0);
}
cmd_spec.out
{:
{
  emit_insn (gen_udivmod<mode>4_split (operands[3], operands[1], operands[2]));
  DONE;
}
 [(set_attr "type" "idiv")
  (set_attr "mode" "<MODE>")
  (set_attr "length" "8")]
:}

abstract set_any_mod2 extends set {
	root.2:=any_mod;
}

concrete <u>divmod<mode>4_split.exp instantiates set_any_mod2 {
	root (register_operand:GPR:"", register_operand:GPR:"", register_operand:GPR:"");
	root.2.mode:=GPR;
}
{:
  ""
{
  rtx hilo;

  if (TARGET_64BIT)
    {
      hilo = gen_rtx_REG (TImode, MD_REG_FIRST);
      emit_insn (gen_<u>divmod<mode>4_hilo_ti (hilo, operands[1],
					       operands[2]));
      emit_insn (gen_mfhi<mode>_ti (operands[0], hilo));
    }
  else
    {
      hilo = gen_rtx_REG (DImode, MD_REG_FIRST);
      emit_insn (gen_<u>divmod<mode>4_hilo_di (hilo, operands[1],
					       operands[2]));
      emit_insn (gen_mfhi<mode>_di (operands[0], hilo));
    }
  DONE;
}
:}
abstract set_unspec2_any_div1 extends set_unspec2 {
	root.2.1:=any_div;
}

concrete <u>divmod<GPR:mode>4_hilo_<HILO:mode>.insn instantiates set_unspec2_any_div1 {
	root (muldiv_target_operand:HILO:"=x", (register_operand:GPR:"d",
		register_operand:GPR:"d", <UNSPEC_SET_HILO>));
	root.2.mode:=HILO; root.2.1.mode:=GPR;
}
{:
  ""
  { return mips_output_division ("<GPR:d>div<u>\t%.,%1,%2", operands); }
  [(set_attr "type" "idiv")
   (set_attr "mode" "<GPR:MODE>")]
:}

{:

;;
;;  ....................
;;
;;	SQUARE ROOT
;;
;;  ....................

;; These patterns work around the early SB-1 rev2 core "F1" erratum (see
;; "*div[sd]f3" comment for details).
:}

concrete sqrt<mode>2.insn instantiates set_sqrt2 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f");
	root.2.mode:=ANYF;
}
{:
  "<sqrt_condition>"
{
  if (TARGET_FIX_SB1)
    return "sqrt.<fmt>\t%0,%1\;mov.<fmt>\t%0,%0";
  else
    return "sqrt.<fmt>\t%0,%1";
}
  [(set_attr "type" "fsqrt")
   (set_attr "mode" "<UNITMODE>")
   (set (attr "length")
        (if_then_else (match_test "TARGET_FIX_SB1")
                      (const_int 8)
                      (const_int 4)))]
:}

abstract set_div2_sqrt2 extends set_div2 {
	root.2.2:=sqrt;
}

concrete *rsqrt<mode>a.insn instantiates set_div2_sqrt2 {
	root (register_operand:ANYF:"=f", const_1_operand:ANYF:"", 
		register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.2.mode:=ANYF;
}
{:
  "<recip_condition> && flag_unsafe_math_optimizations"
{
  if (TARGET_FIX_SB1)
    return "rsqrt.<fmt>\t%0,%2\;mov.<fmt>\t%0,%0";
  else
    return "rsqrt.<fmt>\t%0,%2";
}
  [(set_attr "type" "frsqrt")
   (set_attr "mode" "<UNITMODE>")
   (set (attr "length")
        (if_then_else (match_test "TARGET_FIX_SB1")
                      (const_int 8)
                      (const_int 4)))]
:}

abstract set_sqrt2_div extends set_sqrt2 {
	root.2.1:=div;
}

concrete *rsqrt<mode>b.insn instantiates set_sqrt2_div {
	root (register_operand:ANYF:"=f", const_1_operand:ANYF:"", register_operand:ANYF:"f");
	root.2.mode:=ANYF; root.2.1.mode:=ANYF;
}
{:
  "<recip_condition> && flag_unsafe_math_optimizations"
{
  if (TARGET_FIX_SB1)
    return "rsqrt.<fmt>\t%0,%2\;mov.<fmt>\t%0,%0";
  else
    return "rsqrt.<fmt>\t%0,%2";
}
  [(set_attr "type" "frsqrt")
   (set_attr "mode" "<UNITMODE>")
   (set (attr "length")
        (if_then_else (match_test "TARGET_FIX_SB1")
                      (const_int 8)
                      (const_int 4)))]
:}
{:

;;
;;  ....................
;;
;;	ABSOLUTE VALUE
;;
;;  ....................

;; Do not use the integer abs macro instruction, since that signals an
;; exception on -2147483648 (sigh).

;; abs.fmt is an arithmetic instruction and treats all NaN inputs as
;; invalid; it does not clear their sign bits.  We therefore can't use
;; abs.fmt if the signs of NaNs matter.
:}

concrete abs<mode>2.insn instantiates set_abs2 {
	root (register_operand:ANYF:"=f", register_operand:ANYF:"f");
	root.2.mode:=ANYF;
}
{:
  "!HONOR_NANS (<MODE>mode)"
  "abs.<fmt>\t%0,%1"
  [(set_attr "type" "fabs")
   (set_attr "mode" "<UNITMODE>")]
:}
{:

;;
;;  ...................
;;
;;  Count leading zeroes.
;;
;;  ...................
;;
:}
abstract set_clz2 extends set {
	root.2:=clz;
}
concrete clz<mode>2.insn instantiates set_clz2 {
	root (register_operand:GPR:"=d", register_operand:GPR:"d");
	root.2.mode:=GPR;
}
{:
  "ISA_HAS_CLZ_CLO"
  "<d>clz\t%0,%1"
  [(set_attr "type" "clz")
   (set_attr "mode" "<MODE>")]
:}
{:
;;
;;  ...................
;;
;;  Count number of set bits.
;;
;;  ...................
;;
:}
abstract set_popcount2 extends set {
	root.2:=popcount;
}
concrete popcount<mode>2.insn instantiates set_popcount2 {
	root (register_operand:GPR:"=d", register_operand:GPR:"d");
	root.2.mode:=GPR;
}
{:
  "ISA_HAS_POP"
  "<d>pop\t%0,%1"
  [(set_attr "type" "pop")
   (set_attr "mode" "<MODE>")]
:}
{:

;;
;;  ....................
;;
;;	NEGATION and ONE'S COMPLEMENT
;;
;;  ....................
:}

concrete negsi2.insn instantiates set_neg2 {
	root (register_operand:SI:"=d", register_operand:SI:"d");
	root.2.mode:=SI;
}
{:
  ""
{
  if (TARGET_MIPS16)
    return "neg\t%0,%1";
  else
    return "subu\t%0,%.,%1";
}
  [(set_attr "alu_type"	"sub")
   (set_attr "mode"	"SI")]
:}

concrete negdi2.insn overrides negsi2.insn {
	SI->DI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16"
  "dsubu\t%0,%.,%1"
  [(set_attr "alu_type"	"sub")
   (set_attr "mode"	"DI")]
:}
{:
;; neg.fmt is an arithmetic instruction and treats all NaN inputs as
;; invalid; it does not flip their sign bit.  We therefore can't use
;; neg.fmt if the signs of NaNs matter.
:}

concrete neg<mode>2.insn overrides negsi2.insn {
	SI->ANYF; allconstraints:=("=f", "f");
}
{:
  "!HONOR_NANS (<MODE>mode)"
  "neg.<fmt>\t%0,%1"
  [(set_attr "type" "fneg")
   (set_attr "mode" "<UNITMODE>")]
:}

concrete one_cmpl<mode>2.insn instantiates set_not2 {
	root (register_operand:GPR:"=d", register_operand:GPR:"d");
	root.2.mode:=GPR;

}
{:
  ""
{
  if (TARGET_MIPS16)
    return "not\t%0,%1";
  else
    return "nor\t%0,%.,%1";
}
  [(set_attr "alu_type" "not")
   (set_attr "mode" "<MODE>")]
:}
{:

;;
;;  ....................
;;
;;	LOGICAL
;;
;;  ....................
;;

;; Many of these instructions use trivial define_expands, because we
;; want to use a different set of constraints when TARGET_MIPS16.
:}
concrete and<mode>3.exp instantiates set_and2 {
	root (register_operand:GPR:"", register_operand:GPR:"", 
		and_reg_operand:GPR:""); root.2.mode:=GPR;
}
{:
:}
{:
;; The middle-end is not allowed to convert ANDing with 0xffff_ffff into a
;; zero_extendsidi2 because of TRULY_NOOP_TRUNCATION, so handle these here.
;; Note that this variant does not trigger for SI mode because we require
;; a 64-bit HOST_WIDE_INT and 0xffff_ffff wouldn't be a canonical
;; sign-extended SImode value.
;;
;; These are possible combinations for operand 1 and 2.  The table
;; includes both MIPS and MIPS16 cases.  (r=register, mem=memory,
;; 16=MIPS16, x=match, S=split):
;;
;;     \ op1    r/EXT   r/!EXT  mem   r/16   mem/16
;;  op2
;;
;;  andi           x     x
;;  0xff           x     x       x             x
;;  0xffff         x     x       x             x
;;  0xffff_ffff    x     S       x     S       x
;;  low-bitmask    x
;;  register       x     x
;;  register =op1                      x
:}

concrete *and<mode>3.insn overrides and<mode>3.exp {
	allconstraints:=("=d,d,d,d,d,d,d","o,o,W,d,d,d,d","Yb,Yh,Yw,K,Yx,Yw,d");
	root.2.1.predicate:=nonimmediate_operand; root.2.2.predicate:=and_operand;
}
{:
  "!TARGET_MIPS16 && and_operands_ok (<MODE>mode, operands[1], operands[2])"
{
  int len;

  switch (which_alternative)
    {
    case 0:
      operands[1] = gen_lowpart (QImode, operands[1]);
      return "lbu\t%0,%1";
    case 1:
      operands[1] = gen_lowpart (HImode, operands[1]);
      return "lhu\t%0,%1";
    case 2:
      operands[1] = gen_lowpart (SImode, operands[1]);
      return "lwu\t%0,%1";
    case 3:
      return "andi\t%0,%1,%x2";
    case 4:
      len = low_bitmask_len (<MODE>mode, INTVAL (operands[2]));
      operands[2] = GEN_INT (len);
      return "<d>ext\t%0,%1,0,%2";
    case 5:
      return "#";
    case 6:
      return "and\t%0,%1,%2";
    default:
      gcc_unreachable ();
    }
}
  [(set_attr "move_type" "load,load,load,andi,ext_ins,shift_shift,logical")
   (set_attr "mode" "<MODE>")]
:}

concrete *and<mode>3_mips16.insn overrides *and<mode>3.insn {
	root.1.predicate:=register_operand; root.2.1.predicate:=nonimmediate_operand;
	root.2.2.predicate:=and_operand;
	allconstraints:= ("=d,d,d,d,d","%o,o,W,d,0","Yb,Yh,Yw,Yw,d");
}
{:
  "TARGET_MIPS16 && and_operands_ok (<MODE>mode, operands[1], operands[2])"
{
  switch (which_alternative)
    {
    case 0:
      operands[1] = gen_lowpart (QImode, operands[1]);
      return "lbu\t%0,%1";
    case 1:
      operands[1] = gen_lowpart (HImode, operands[1]);
      return "lhu\t%0,%1";
    case 2:
      operands[1] = gen_lowpart (SImode, operands[1]);
      return "lwu\t%0,%1";
    case 3:
      return "#";
    case 4:
      return "and\t%0,%2";
    default:
      gcc_unreachable ();
    }
}
  [(set_attr "move_type" "load,load,load,shift_shift,logical")
   (set_attr "mode" "<MODE>")]
:}

concrete ior<mode>3.exp instantiates set_ior2 {
	root (register_operand:GPR:"", register_operand:GPR:"", uns_arith_operand:GPR:"");
	root.2.mode:=GPR;
}
{:
  ""
{
  if (TARGET_MIPS16)
    operands[2] = force_reg (<MODE>mode, operands[2]);
}
:}

concrete *ior<mode>3.insn overrides ior<mode>3.exp {
	allconstraints:=("=d,d", "%d,d", "d,K");
}
{:
  "!TARGET_MIPS16"
  "@
   or\t%0,%1,%2
   ori\t%0,%1,%x2"
  [(set_attr "alu_type" "or")
   (set_attr "mode" "<MODE>")]
:}

concrete *ior<mode>3_mips16.insn overrides ior<mode>3.exp {
	allconstraints:=("=d", "%0", "d"); root.2.2.predicate:=register_operand;
}
{:
  "TARGET_MIPS16"
  "or\t%0,%2"
  [(set_attr "alu_type" "or")
   (set_attr "mode" "<MODE>")]
:}

concrete xor<mode>3.exp instantiates set_xor2 {
	root (register_operand:GPR:"", register_operand:GPR:"",
		uns_arith_operand:GPR:""); root.2.mode:=GPR;
}
{:
  ""
  ""
:}
// TODO Blank instructions
{:
(define_insn ""
  [(set (match_operand:GPR 0 "register_operand" "=d,d")
	(xor:GPR (match_operand:GPR 1 "register_operand" "%d,d")
		 (match_operand:GPR 2 "uns_arith_operand" "d,K")))]
  "!TARGET_MIPS16"
  "@
   xor\t%0,%1,%2
   xori\t%0,%1,%x2"
  [(set_attr "alu_type" "xor")
   (set_attr "mode" "<MODE>")])


(define_insn ""
  [(set (match_operand:GPR 0 "register_operand" "=d,t,t")
	(xor:GPR (match_operand:GPR 1 "register_operand" "%0,d,d")
		 (match_operand:GPR 2 "uns_arith_operand" "d,K,d")))]
  "TARGET_MIPS16"
  "@
   xor\t%0,%2
   cmpi\t%1,%2
   cmp\t%1,%2"
  [(set_attr "alu_type" "xor")
   (set_attr "mode" "<MODE>")
   (set_attr_alternative "length"
		[(const_int 4)
		 (if_then_else (match_operand:VOID 2 "m16_uimm8_1")
			       (const_int 4)
			       (const_int 8))
		 (const_int 4)])])
:}

abstract set_and2_not1_not2 extends set_and2 {
	root.2.1:=not; root.2.2:=not;
}

concrete *nor<mode>3.insn instantiates set_and2_not1_not2 {
	root (register_operand:GPR:"=d", register_operand:GPR:"d", register_operand:GPR:"d");
	root.2.mode:=GPR; root.2.1.mode:=GPR; root.2.2.mode:=GPR;
}
{:
  "!TARGET_MIPS16"
  "nor\t%0,%1,%2"
  [(set_attr "alu_type" "nor")
   (set_attr "mode" "<MODE>")]
:}
{:

;;
;;  ....................
;;
;;	TRUNCATION
;;
;;  ....................
:}

concrete truncdfsf2.insn instantiates set_float_truncate2 {
	root (register_operand:SF:"=f", register_operand:DF:"f");
	root.2.mode:=SF;
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
  "cvt.s.d\t%0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "cnv_mode"	"D2S")   
   (set_attr "mode"	"SF")]
:}
{:
;; Integer truncation patterns.  Truncating SImode values to smaller
;; modes is a no-op, as it is for most other GCC ports.  Truncating
;; DImode values to SImode is not a no-op for TARGET_64BIT since we
;; need to make sure that the lower 32 bits are properly sign-extended
;; (see TRULY_NOOP_TRUNCATION).  Truncating DImode values into modes
;; smaller than SImode is equivalent to two separate truncations:
;;
;;                        A       B
;;    DI ---> HI  ==  DI ---> SI ---> HI
;;    DI ---> QI  ==  DI ---> SI ---> QI
;;
;; Step A needs a real instruction but step B does not.
:}

concrete truncdi<mode>2.insn instantiates set_truncate2 {
	root (nonimmediate_operand:SUBDI:"=d,m",register_operand:DI:"d,d");
	root.2.mode:=SUBDI;
}
{:
  "TARGET_64BIT"
  "@
    sll\t%0,%1,0
    <store>\t%1,%0"
  [(set_attr "move_type" "sll0,store")
   (set_attr "mode" "SI")]
:}
{:
;; Combiner patterns to optimize shift/truncate combinations.
:}
abstract set_truncate2_ashiftrt1 extends set_truncate2 {
	root.2.1:=ashiftrt;
}
concrete *ashr_trunc<mode>.insn instantiates set_truncate2_ashiftrt1 {
	root (register_operand:SUBDI:"=d", register_operand:DI:"d", 
		const_arith_operand:DI:""); root.2.mode:=SUBDI; root.2.1.mode:=DI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16 && IN_RANGE (INTVAL (operands[2]), 32, 63)"
  "dsra\t%0,%1,%2"
  [(set_attr "type" "shift")
   (set_attr "mode" "<MODE>")]
:}

abstract set_truncate2_lshiftrt1 extends set_truncate2 {
	root.2.1:=lshiftrt;
}

concrete *lshr32_trunc<mode>.insn instantiates set_truncate2_lshiftrt1 {
	root (register_operand:SUBDI:"=d", register_operand:DI:"d", const_int:32);
	root.2.mode:=SUBDI; root.2.1.mode:=DI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16"
  "dsra\t%0,%1,32"
  [(set_attr "type" "shift")
   (set_attr "mode" "<MODE>")]
:}
{:
;; Logical shift by more than 32 results in proper SI values so truncation is
;; removed by the middle end.  Note that a logical shift by 32 is handled by
;; the previous pattern.
:}
abstract set_truncate2_any_shiftrt1 extends set_truncate2 {
	root.2.1:=any_shiftrt;
}
concrete *<optab>_trunc<mode>_exts.insn instantiates set_truncate2_any_shiftrt1 {
	root (register_operand:SUBDI:"=d", register_operand:DI:"d", const_arith_operand:DI:"");
	root.2.mode:=SUBDI; root.2.1.mode:=DI;
}
{:
  "ISA_HAS_EXTS && TARGET_64BIT && UINTVAL (operands[2]) < 32"
  "exts\t%0,%1,%2,31"
  [(set_attr "type" "arith")
   (set_attr "mode" "<MODE>")]
:}
{:

;;
;;  ....................
;;
;;	ZERO EXTENSION
;;
;;  ....................

;; Extension insns.
:}

concrete zero_extendsidi2.exp instantiates set_zero_extend2 {
	root (register_operand:DI:"", nonimmediate_operand:SI:"");
	root.2.mode:=DI;
}
{:
  "TARGET_64BIT"
:}

abstract set_ashift2_set_lshiftrt2 extends sequence {
	root.1:=set_ashift2; root.2:=set_lshiftrt2;
}

concrete *zero_extendsidi2.insn_and_split instantiates.in set_zero_extend2 {
	root (register_operand:DI:"=d,d", nonimmediate_operand:SI:"d,W");
	root.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_64BIT && !ISA_HAS_EXT_INS"
  "@
   #
   lwu\t%0,%1"
  "&& reload_completed && REG_P (operands[1])"
:}
instantiates.out set_ashift2_set_lshiftrt2 {
	root (duplicate 0, duplicate 1, const_int:32, duplicate 0, duplicate 0, 
		const_int:32); root.1.2.mode:=DI; root.2.2.mode:=DI;
}
cmd_spec.out
{:
  { operands[1] = gen_lowpart (DImode, operands[1]); }
  [(set_attr "move_type" "shift_shift,load")
   (set_attr "mode" "DI")]
:}

concrete *zero_extendsidi2_dext.insn overrides zero_extendsidi2.exp {
	allconstraints:=("=d,d", "d,W");
}
{:
  "TARGET_64BIT && ISA_HAS_EXT_INS"
  "@
   dext\t%0,%1,0,32
   lwu\t%0,%1"
  [(set_attr "move_type" "arith,load")
   (set_attr "mode" "DI")]
:}
{:
;; See the comment before the *and<mode>3 pattern why this is generated by
;; combine.
:}

concrete .split instantiates.in set_and2 {
	root (register_operand:DI:"", register_operand:DI:"", 
	const_int:4294967295); root.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_64BIT && !ISA_HAS_EXT_INS && reload_completed"
:}
instantiates.out set_ashift2_set_lshiftrt2 {
	root (duplicate 0, duplicate 1, const_int:32, duplicate 0,
		duplicate 0, const_int:32); root.1.2.mode:=DI; root.2.2.mode:=DI;
}
cmd_spec.out 
{:
:}
concrete zero_extend<SHORT:mode><GPR:mode>2.exp overrides zero_extendsidi2.exp {
	DI->GPR; SI->SHORT; root.2.mode:=GPR;
}
{:
  ""
{
  if (TARGET_MIPS16 && !GENERATE_MIPS16E
      && !memory_operand (operands[1], <SHORT:MODE>mode))
    {
      emit_insn (gen_and<GPR:mode>3 (operands[0],
				     gen_lowpart (<GPR:MODE>mode, operands[1]),
				     force_reg (<GPR:MODE>mode,
						GEN_INT (<SHORT:mask>))));
      DONE;
    }
}
:}

concrete *zero_extend<SHORT:mode><GPR:mode>2.insn overrides zero_extend<SHORT:mode><GPR:mode>2.exp {
	allconstraints:=("=d,d","d,m");
}
{:
  "!TARGET_MIPS16"
  "@
   andi\t%0,%1,<SHORT:mask>
   l<SHORT:size>u\t%0,%1"
  [(set_attr "move_type" "andi,load")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *zero_extend<SHORT:mode><GPR:mode>2_mips16e.insn overrides zero_extend<SHORT:mode><GPR:mode>2.exp {
	allconstraints:= ("=d", "0"); root.2.1.predicate:=register_operand;
}
{:
  "GENERATE_MIPS16E"
  "ze<SHORT:size>\t%0"
  ;; This instruction is effectively a special encoding of ANDI.
  [(set_attr "move_type" "andi")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *zero_extend<SHORT:mode><GPR:mode>2_mips16.insn overrides zero_extend<SHORT:mode><GPR:mode>2.exp {
	allconstraints:=("=d","m");	root.2.1.predicate:=memory_operand;
}
{:
  "TARGET_MIPS16"
  "l<SHORT:size>u\t%0,%1"
  [(set_attr "move_type" "load")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete zero_extendqihi2.exp overrides zero_extendsidi2.exp {
	DI->HI; SI->QI; root.2.mode:=HI;
}
{:
  ""
{
  if (TARGET_MIPS16 && !memory_operand (operands[1], QImode))
    {
      emit_insn (gen_zero_extendqisi2 (gen_lowpart (SImode, operands[0]),
				       operands[1]));
      DONE;
    }
}
:}

concrete *zero_extendqihi2.insn overrides zero_extendqihi2.exp {
	allconstraints:= ("=d,d", "d,m");
}
{:
  "!TARGET_MIPS16"
  "@
   andi\t%0,%1,0x00ff
   lbu\t%0,%1"
  [(set_attr "move_type" "andi,load")
   (set_attr "mode" "HI")]
:}

concrete *zero_extendqihi2_mips16.insn overrides zero_extendqihi2.exp {
	allconstraints:=("=d","m"); root.2.predicate:=memory_operand;
}
{:
  "TARGET_MIPS16"
  "lbu\t%0,%1"
  [(set_attr "move_type" "load")
   (set_attr "mode" "HI")]
:}

{:
;; Combiner patterns to optimize truncate/zero_extend combinations.
:}
abstract set_zero_extend2_truncate1 extends set_zero_extend2 {
	root.2.1:=truncate;
}
concrete *zero_extend<GPR:mode>_trunc<SHORT:mode>.insn instantiates set_zero_extend2_truncate1 {
	root (register_operand:GPR:"=d", register_operand:DI:"d");
	root.2.mode:=GPR; root.2.1.mode:=SHORT;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16"
{
  operands[2] = GEN_INT (GET_MODE_MASK (<SHORT:MODE>mode));
  return "andi\t%0,%1,%x2";
}
  [(set_attr "alu_type" "and")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *zero_extendhi_truncqi.insn overrides *zero_extend<GPR:mode>_trunc<SHORT:mode>.insn {
	GPR->HI; SHORT->QI;root.2.mode:=HI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16"
  "andi\t%0,%1,0xff"
  [(set_attr "alu_type" "and")
   (set_attr "mode" "HI")]
:}
{:

;;
;;  ....................
;;
;;	SIGN EXTENSION
;;
;;  ....................

;; Extension insns.
;; Those for integer source operand are ordered widest source type first.

;; When TARGET_64BIT, all SImode integer and accumulator registers
;; should already be in sign-extended form (see TRULY_NOOP_TRUNCATION
;; and truncdisi2).  We can therefore get rid of register->register
;; instructions if we constrain the source to be in the same register as
;; the destination.
;;
;; Only the pre-reload scheduler sees the type of the register alternatives;
;; we split them into nothing before the post-reload scheduler runs.
;; These alternatives therefore have type "move" in order to reflect
;; what happens if the two pre-reload operands cannot be tied, and are
;; instead allocated two separate GPRs.  We don't distinguish between
;; the GPR and LO cases because we don't usually know during pre-reload
;; scheduling whether an operand will be LO or not.
:}

concrete extendsidi2.insn_and_split instantiates.in set_sign_extend2 {
	root (register_operand:DI:"=d,l,d", nonimmediate_operand:SI:"0,0,m");
	root.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_64BIT"
  "@
   #
   #
   lw\t%0,%1"
  "&& reload_completed && register_operand (operands[1], VOIDmode)"
:}
instantiates.out sequence {
  root (const_int:0);
}
cmd_spec.out {:
{
  emit_note (NOTE_INSN_DELETED);
  DONE;
}
  [(set_attr "move_type" "move,move,load")
   (set_attr "mode" "DI")]
:}

concrete extend<SHORT:mode><GPR:mode>2.exp instantiates set_sign_extend2 {
	root (register_operand:GPR:"", nonimmediate_operand:SHORT:""); root.2.mode:=GPR;
}
{:
  ""
:}

concrete *extend<SHORT:mode><GPR:mode>2_mips16e.insn overrides extend<SHORT:mode><GPR:mode>2.exp {
	allconstraints:=("=d,d","0,m");
}
{:
  "GENERATE_MIPS16E"
  "@
   se<SHORT:size>\t%0
   l<SHORT:size>\t%0,%1"
  [(set_attr "move_type" "signext,load")
   (set_attr "mode" "<GPR:MODE>")]
:}
abstract set_ashift2_set_ashiftrt2 extends sequence {
	root.1:=set_ashift2; root.2:=set_ashiftrt2;
}
concrete *extend<SHORT:mode><GPR:mode>2.insn_and_split instantiates.in set_sign_extend2 {
	root (register_operand:GPR:"=d,d", nonimmediate_operand:SHORT:"d,m"); root.2.mode:=GPR;
}
cmd_spec.in
{:
  "!ISA_HAS_SEB_SEH && !GENERATE_MIPS16E"
  "@
   #
   l<SHORT:size>\t%0,%1"
  "&& reload_completed && REG_P (operands[1])"
:}
instantiates.out set_ashift2_set_ashiftrt2 {
	root (duplicate 0, duplicate 1, duplicate 2, duplicate 0,
		duplicate 0, duplicate 2); root.1.2.mode:=GPR; root.2.2.mode:=GPR;
}
cmd_spec.out
{:
{
  operands[1] = gen_lowpart (<GPR:MODE>mode, operands[1]);
  operands[2] = GEN_INT (GET_MODE_BITSIZE (<GPR:MODE>mode)
			 - GET_MODE_BITSIZE (<SHORT:MODE>mode));
}
  [(set_attr "move_type" "shift_shift,load")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *extend<SHORT:mode><GPR:mode>2_se<SHORT:size>.insn overrides extend<SHORT:mode><GPR:mode>2.exp {
	allconstraints:=("=d,d", "d,m");
}
{:
  "ISA_HAS_SEB_SEH"
  "@
   se<SHORT:size>\t%0,%1
   l<SHORT:size>\t%0,%1"
  [(set_attr "move_type" "signext,load")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete extendqihi2.exp overrides extend<SHORT:mode><GPR:mode>2.exp {
	GPR->HI; SHORT->QI; root.2.mode:=HI;
}
{:
  ""
:}

concrete *extendqihi2_mips16e.insn overrides extendqihi2.exp {
	allconstraints:=("=d,d", "0,m");
}
{:
  "GENERATE_MIPS16E"
  "@
   seb\t%0
   lb\t%0,%1"
  [(set_attr "move_type" "signext,load")
   (set_attr "mode" "SI")]
:}

concrete *extendqihi2.insn_and_split instantiates.in set_sign_extend2{
	root (register_operand:HI:"=d,d", nonimmediate_operand:QI:"d,m");
	root.2.mode:=HI;
}
cmd_spec.in
{:
  "!ISA_HAS_SEB_SEH && !GENERATE_MIPS16E"
  "@
   #
   lb\t%0,%1"
  "&& reload_completed && REG_P (operands[1])"
:}
instantiates.out set_ashift2_set_ashiftrt2 {
	root (duplicate 0,duplicate 1,duplicate 2,duplicate 0, 
		duplicate 0, duplicate 2);
	root.1.2.mode:=SI;  root.2.2.mode:=SI; root.2.2.mode:=SI;
}
cmd_spec.out 
{:
{
  operands[0] = gen_lowpart (SImode, operands[0]);
  operands[1] = gen_lowpart (SImode, operands[1]);
  operands[2] = GEN_INT (GET_MODE_BITSIZE (SImode)
			 - GET_MODE_BITSIZE (QImode));
}
  [(set_attr "move_type" "shift_shift,load")
   (set_attr "mode" "SI")]
:}

concrete *extendqihi2_seb.insn overrides extendqihi2.exp {
	allconstraints:=("=d,d", "d,m");
}
{:
  "ISA_HAS_SEB_SEH"
  "@
   seb\t%0,%1
   lb\t%0,%1"
  [(set_attr "move_type" "signext,load")
   (set_attr "mode" "SI")]
:}
{:
;; Combiner patterns for truncate/sign_extend combinations.  The SI versions
;; use the shift/truncate patterns.
:}
abstract set_sign_extend2_truncate1 extends set_sign_extend2 {
	root.2.1:=truncate;
}

concrete *extenddi_truncate<mode>.insn_and_split instantiates.in set_sign_extend2_truncate1 {
	root (register_operand:DI:"=d", register_operand:DI:"d"); root.2.mode:=DI; root.2.1.mode:=SHORT;
}
cmd_spec.in
{:
  "TARGET_64BIT && !TARGET_MIPS16 && !ISA_HAS_EXTS"
  "#"
  "&& reload_completed"
:}
instantiates.out set_ashift2_set_ashiftrt2 {
	root (duplicate 2, duplicate 1, duplicate 3, duplicate 0,
		duplicate 2, duplicate 3); root.1.2.mode:=DI; root.2.2.mode:=DI;
}
cmd_spec.out
{:
{
  operands[2] = gen_lowpart (DImode, operands[0]);
  operands[3] = GEN_INT (BITS_PER_WORD - GET_MODE_BITSIZE (<MODE>mode));
}
  [(set_attr "move_type" "shift_shift")
   (set_attr "mode" "DI")]
:}

abstract set_ashift2_set_truncate2_ashiftrt1 extends sequence {
	root.1:=set_ashift2; root.2:=set_truncate2_ashiftrt1;
}

concrete *extendsi_truncate<mode>.insn_and_split instantiates.in set_sign_extend2_truncate1 {
	root (register_operand:SI:"=d",register_operand:DI:"d"); root.2.mode:=SI;root.2.1.mode:=SHORT;
}
cmd_spec.in
{:
  "TARGET_64BIT && !TARGET_MIPS16 && !ISA_HAS_EXTS"
  "#"
  "&& reload_completed"
:}
instantiates.out set_ashift2_set_truncate2_ashiftrt1 {
	root (duplicate 2, duplicate 1, duplicate 3, duplicate 0, duplicate 2,
		duplicate 3); root.1.2.mode:=DI; root.2.2.mode:=SI; root.2.2.1.mode:=DI;
}
cmd_spec.out
{:
{
  operands[2] = gen_lowpart (DImode, operands[0]);
  operands[3] = GEN_INT (BITS_PER_WORD - GET_MODE_BITSIZE (<MODE>mode));
}
  [(set_attr "move_type" "shift_shift")
   (set_attr "mode" "SI")]
:}

concrete *extendhi_truncateqi.insn_and_split instantiates.in set_sign_extend2_truncate1 {
	root (register_operand:HI:"=d", register_operand:DI:"d"); root.2.mode:=HI; root.2.1.mode:=QI;
}
cmd_spec.in
{:
  "TARGET_64BIT && !TARGET_MIPS16 && !ISA_HAS_EXTS"
  "#"
  "&& reload_completed"
:}
instantiates.out set_ashift2_set_truncate2_ashiftrt1 {
	root (duplicate 2, duplicate 1, const_int:56, duplicate 0, duplicate 2,
		const_int:56); root.1.2.mode:=DI; root.2.2.mode:=HI; root.2.2.1.mode:=DI;
}
cmd_spec.out
{:
{
  operands[2] = gen_lowpart (DImode, operands[0]);
}
  [(set_attr "move_type" "shift_shift")
   (set_attr "mode" "SI")]
:}

concrete *extend<GPR:mode>_truncate<SHORT:mode>_exts.insn instantiates set_sign_extend2_truncate1 {
	root (register_operand:GPR:"=d", register_operand:DI:"d"); root.2.mode:=GPR; root.2.1.mode:=SHORT;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16 && ISA_HAS_EXTS"
{
  operands[2] = GEN_INT (GET_MODE_BITSIZE (<SHORT:MODE>mode));
  return "exts\t%0,%1,0,%m2";
}
  [(set_attr "type" "arith")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *extendhi_truncateqi_exts.insn overrides *extend<GPR:mode>_truncate<SHORT:mode>_exts.insn {
	GPR->HI; SHORT->QI; root.2.mode:=HI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16 && ISA_HAS_EXTS"
  "exts\t%0,%1,0,7"
  [(set_attr "type" "arith")
   (set_attr "mode" "SI")]
:}
abstract set_float_extend2 extends set {
	root.2:=float_extend;
}
concrete extendsfdf2.insn instantiates set_float_extend2 {
	root (register_operand:DF:"=f", register_operand:SF:"f"); root.2.mode:=DF;
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
  "cvt.d.s\t%0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "cnv_mode"	"S2D")   
   (set_attr "mode"	"DF")]
:}
{:

;;
;;  ....................
;;
;;	CONVERSIONS
;;
;;  ....................
:}

concrete fix_truncdfsi2.exp instantiates set_fix2 {
	root (register_operand:SI:"", register_operand:DF:""); root.2.mode:=SI;
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
{
  if (!ISA_HAS_TRUNC_W)
    {
      emit_insn (gen_fix_truncdfsi2_macro (operands[0], operands[1]));
      DONE;
    }
}
:}

concrete fix_truncdfsi2_insn.insn overrides fix_truncdfsi2.exp {
	allconstraints:=("=f","f");
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && ISA_HAS_TRUNC_W"
  "trunc.w.d %0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"DF")
   (set_attr "cnv_mode"	"D2I")]
:}
abstract set_fix2_clobber extends sequence {
	root.1:=set_fix2; root.2:=clobber;
}
concrete fix_truncdfsi2_macro.insn instantiates set_fix2_clobber {
	root (register_operand:SI:"=f", register_operand:DF:"f", 2=DF:"=d");
	root.1.2.mode:=SI;
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !ISA_HAS_TRUNC_W"
{
  if (mips_nomacro.nesting_level > 0)
    return ".set\tmacro\;trunc.w.d %0,%1,%2\;.set\tnomacro";
  else
    return "trunc.w.d %0,%1,%2";
}
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"DF")
   (set_attr "cnv_mode"	"D2I")
   (set_attr "length"	"36")]
:}

concrete fix_truncsfsi2.exp overrides fix_truncdfsi2.exp {
	root.2.mode:=SI; root.2.1.mode:=SF;
}
{:
  "TARGET_HARD_FLOAT"
{
  if (!ISA_HAS_TRUNC_W)
    {
      emit_insn (gen_fix_truncsfsi2_macro (operands[0], operands[1]));
      DONE;
    }
}
:}

concrete fix_truncsfsi2_insn.insn overrides fix_truncsfsi2.exp {
	allconstraints:=("=f","f");
}
{:
  "TARGET_HARD_FLOAT && ISA_HAS_TRUNC_W"
  "trunc.w.s %0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"SF")
   (set_attr "cnv_mode"	"S2I")]
:}

concrete fix_truncsfsi2_macro.insn instantiates set_fix2_clobber {
	root (register_operand:SI:"=f", register_operand:SF:"f", 2=SF:"=d"); root.1.2.mode:=SI;
}
{:
  "TARGET_HARD_FLOAT && !ISA_HAS_TRUNC_W"
{
  if (mips_nomacro.nesting_level > 0)
    return ".set\tmacro\;trunc.w.s %0,%1,%2\;.set\tnomacro";
  else
    return "trunc.w.s %0,%1,%2";
}
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"SF")
   (set_attr "cnv_mode"	"S2I")
   (set_attr "length"	"36")]
:}

concrete fix_truncdfdi2.insn overrides fix_truncsfsi2.exp {
	SF->DF; SI->DI; allconstraints:=("=f","f"); root.2.1.mode:=DF;
}
{:
  "TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT"
  "trunc.l.d %0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"DF")
   (set_attr "cnv_mode"	"D2I")]
:}

concrete fix_truncsfdi2.insn overrides fix_truncsfsi2.exp {
	SI->DI; allconstraints:=("=f","f");
}
{:
  "TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT"
  "trunc.l.s %0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"SF")
   (set_attr "cnv_mode"	"S2I")]
:}

concrete floatsidf2.insn instantiates set_float2 {
	root (register_operand:DF:"=f", register_operand:SI:"f");
	root.2.mode:=DF;
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
  "cvt.d.w\t%0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"DF")
   (set_attr "cnv_mode"	"I2D")]
:}

concrete floatdidf2.insn overrides floatsidf2.insn {
	SI->DI;
}
{:
  "TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT"
  "cvt.d.l\t%0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"DF")
   (set_attr "cnv_mode"	"I2D")]
:}

concrete floatsisf2.insn overrides floatsidf2.insn {
	DF->SF;
}
{:
  "TARGET_HARD_FLOAT"
  "cvt.s.w\t%0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"SF")
   (set_attr "cnv_mode"	"I2S")]
:}

concrete floatdisf2.insn overrides floatsidf2.insn {
	SI->DI; DF->SF;
}
{:
  "TARGET_HARD_FLOAT && TARGET_FLOAT64 && TARGET_DOUBLE_FLOAT"
  "cvt.s.l\t%0,%1"
  [(set_attr "type"	"fcvt")
   (set_attr "mode"	"SF")
   (set_attr "cnv_mode"	"I2S")]
:}

concrete fixuns_truncdfsi2.exp instantiates set_unsigned_fix2 {
	root (register_operand:SI:"",register_operand:DF:""); root.2.mode:=SI;
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
{
  rtx reg1 = gen_reg_rtx (DFmode);
  rtx reg2 = gen_reg_rtx (DFmode);
  rtx reg3 = gen_reg_rtx (SImode);
  rtx label1 = gen_label_rtx ();
  rtx label2 = gen_label_rtx ();
  rtx test;
  REAL_VALUE_TYPE offset;

  real_2expN (&offset, 31, DFmode);

  if (reg1)			/* Turn off complaints about unreached code.  */
    {
      mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));
      do_pending_stack_adjust ();

      test = gen_rtx_GE (VOIDmode, operands[1], reg1);
      emit_jump_insn (gen_cbranchdf4 (test, operands[1], reg1, label1));

      emit_insn (gen_fix_truncdfsi2 (operands[0], operands[1]));
      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
				   gen_rtx_LABEL_REF (VOIDmode, label2)));
      emit_barrier ();

      emit_label (label1);
      mips_emit_move (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));
      mips_emit_move (reg3, GEN_INT (trunc_int_for_mode
				     (BITMASK_HIGH, SImode)));

      emit_insn (gen_fix_truncdfsi2 (operands[0], reg2));
      emit_insn (gen_iorsi3 (operands[0], operands[0], reg3));

      emit_label (label2);

      /* Allow REG_NOTES to be set on last insn (labels don't have enough
	 fields, and can't be used for REG_NOTES anyway).  */
      emit_use (stack_pointer_rtx);
      DONE;
    }
}
:}

concrete fixuns_truncdfdi2.exp overrides fixuns_truncdfsi2.exp {
	SI->DI;
}
{:
  "TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT"
{
  rtx reg1 = gen_reg_rtx (DFmode);
  rtx reg2 = gen_reg_rtx (DFmode);
  rtx reg3 = gen_reg_rtx (DImode);
  rtx label1 = gen_label_rtx ();
  rtx label2 = gen_label_rtx ();
  rtx test;
  REAL_VALUE_TYPE offset;

  real_2expN (&offset, 63, DFmode);

  mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, DFmode));
  do_pending_stack_adjust ();

  test = gen_rtx_GE (VOIDmode, operands[1], reg1);
  emit_jump_insn (gen_cbranchdf4 (test, operands[1], reg1, label1));

  emit_insn (gen_fix_truncdfdi2 (operands[0], operands[1]));
  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
			       gen_rtx_LABEL_REF (VOIDmode, label2)));
  emit_barrier ();

  emit_label (label1);
  mips_emit_move (reg2, gen_rtx_MINUS (DFmode, operands[1], reg1));
  mips_emit_move (reg3, GEN_INT (BITMASK_HIGH));
  emit_insn (gen_ashldi3 (reg3, reg3, GEN_INT (32)));

  emit_insn (gen_fix_truncdfdi2 (operands[0], reg2));
  emit_insn (gen_iordi3 (operands[0], operands[0], reg3));

  emit_label (label2);

  /* Allow REG_NOTES to be set on last insn (labels don't have enough
     fields, and can't be used for REG_NOTES anyway).  */
  emit_use (stack_pointer_rtx);
  DONE;
}
:}

concrete fixuns_truncsfsi2.exp overrides fixuns_truncdfsi2.exp {
	DF->SF;
}
{:
  "TARGET_HARD_FLOAT"
{
  rtx reg1 = gen_reg_rtx (SFmode);
  rtx reg2 = gen_reg_rtx (SFmode);
  rtx reg3 = gen_reg_rtx (SImode);
  rtx label1 = gen_label_rtx ();
  rtx label2 = gen_label_rtx ();
  rtx test;
  REAL_VALUE_TYPE offset;

  real_2expN (&offset, 31, SFmode);

  mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));
  do_pending_stack_adjust ();

  test = gen_rtx_GE (VOIDmode, operands[1], reg1);
  emit_jump_insn (gen_cbranchsf4 (test, operands[1], reg1, label1));

  emit_insn (gen_fix_truncsfsi2 (operands[0], operands[1]));
  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
			       gen_rtx_LABEL_REF (VOIDmode, label2)));
  emit_barrier ();

  emit_label (label1);
  mips_emit_move (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));
  mips_emit_move (reg3, GEN_INT (trunc_int_for_mode
				 (BITMASK_HIGH, SImode)));

  emit_insn (gen_fix_truncsfsi2 (operands[0], reg2));
  emit_insn (gen_iorsi3 (operands[0], operands[0], reg3));

  emit_label (label2);

  /* Allow REG_NOTES to be set on last insn (labels don't have enough
     fields, and can't be used for REG_NOTES anyway).  */
  emit_use (stack_pointer_rtx);
  DONE;
}
:}
concrete fixuns_truncsfdi2.exp overrides fixuns_truncsfsi2.exp {
	SI->DI; DF->SF; root.2.mode:=DI;
}
{:
  "TARGET_HARD_FLOAT && TARGET_64BIT && TARGET_DOUBLE_FLOAT"
{
  rtx reg1 = gen_reg_rtx (SFmode);
  rtx reg2 = gen_reg_rtx (SFmode);
  rtx reg3 = gen_reg_rtx (DImode);
  rtx label1 = gen_label_rtx ();
  rtx label2 = gen_label_rtx ();
  rtx test;
  REAL_VALUE_TYPE offset;

  real_2expN (&offset, 63, SFmode);

  mips_emit_move (reg1, CONST_DOUBLE_FROM_REAL_VALUE (offset, SFmode));
  do_pending_stack_adjust ();

  test = gen_rtx_GE (VOIDmode, operands[1], reg1);
  emit_jump_insn (gen_cbranchsf4 (test, operands[1], reg1, label1));

  emit_insn (gen_fix_truncsfdi2 (operands[0], operands[1]));
  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
			       gen_rtx_LABEL_REF (VOIDmode, label2)));
  emit_barrier ();

  emit_label (label1);
  mips_emit_move (reg2, gen_rtx_MINUS (SFmode, operands[1], reg1));
  mips_emit_move (reg3, GEN_INT (BITMASK_HIGH));
  emit_insn (gen_ashldi3 (reg3, reg3, GEN_INT (32)));

  emit_insn (gen_fix_truncsfdi2 (operands[0], reg2));
  emit_insn (gen_iordi3 (operands[0], operands[0], reg3));

  emit_label (label2);

  /* Allow REG_NOTES to be set on last insn (labels don't have enough
     fields, and can't be used for REG_NOTES anyway).  */
  emit_use (stack_pointer_rtx);
  DONE;
}
:}
{:

;;
;;  ....................
;;
;;	DATA MOVEMENT
;;
;;  ....................

;; Bit field extract patterns which use lwl/lwr or ldl/ldr.
:}

concrete extv.exp instantiates set_sign_extract2 {
	root (register_operand:NULL:"", nonimmediate_operand:NULL:"",
		const_int_operand:NULL:"",const_int_operand:NULL:"");
}
{:
  "!TARGET_MIPS16"
{
  if (mips_expand_ext_as_unaligned_load (operands[0], operands[1],
					 INTVAL (operands[2]),
					 INTVAL (operands[3])))
    DONE;
  else if (register_operand (operands[1], GET_MODE (operands[0]))
	   && ISA_HAS_EXTS && UINTVAL (operands[2]) <= 32)
    {
      if (GET_MODE (operands[0]) == DImode)
	emit_insn (gen_extvdi (operands[0], operands[1], operands[2],
			       operands[3]));
      else
	emit_insn (gen_extvsi (operands[0], operands[1], operands[2],
			       operands[3]));
      DONE;
    }
  else
    FAIL;
}
:}

concrete extv<mode>.insn overrides extv.exp {
	allconstraints:=("=d","d"); root.2.predicate:=register_operand;
	root.1.mode:=GPR; root.2.mode:=GPR; root.2.1.mode:=GPR;
}
{:
  "ISA_HAS_EXTS && UINTVAL (operands[2]) <= 32"
  "exts\t%0,%1,%3,%m2"
  [(set_attr "type"     "arith")
   (set_attr "mode"     "<MODE>")]
:}

concrete extzv.exp instantiates set_zero_extract2 {
	root (register_operand:NULL:"", nonimmediate_operand:NULL:"",
		const_int_operand:NULL:"", const_int_operand:NULL:"");
}
{:
	"!TARGET_MIPS16"
{
  if (mips_expand_ext_as_unaligned_load (operands[0], operands[1],
					 INTVAL (operands[2]),
					 INTVAL (operands[3])))
    DONE;
  else if (mips_use_ins_ext_p (operands[1], INTVAL (operands[2]),
			       INTVAL (operands[3])))
    {
      if (GET_MODE (operands[0]) == DImode)
        emit_insn (gen_extzvdi (operands[0], operands[1], operands[2],
				operands[3]));
      else
        emit_insn (gen_extzvsi (operands[0], operands[1], operands[2],
				operands[3]));
      DONE;
    }
  else
    FAIL;
}
:}

concrete extzv<mode>.insn overrides extzv.exp {
	root.1.mode:=GPR; root.2.mode:=GPR; root.2.1.mode:=GPR;
	allconstraints:= ("=d","d"); root.2.1.predicate:=register_operand;
}
{:
  "mips_use_ins_ext_p (operands[1], INTVAL (operands[2]),
		       INTVAL (operands[3]))"
  "<d>ext\t%0,%1,%3,%2"
  [(set_attr "type"	"arith")
   (set_attr "mode"	"<MODE>")]
:}
abstract set_truncate2_zero_extract1 extends set_truncate2 {
	root.2.1:=zero_extract;
}
concrete *extzv_truncsi_exts.insn instantiates set_truncate2_zero_extract1 {
	root (register_operand:SI:"=d", register_operand:DI:"d",
		const_int_operand:NULL:"", const_int_operand:NULL:"");
	root.2.mode:=SI; root.2.1.mode:=DI;
}
{:
  "ISA_HAS_EXTS && TARGET_64BIT && IN_RANGE (INTVAL (operands[2]), 32, 63)"
  "exts\t%0,%1,%3,31"
  [(set_attr "type"     "arith")
   (set_attr "mode"     "SI")]
:}

concrete insv.exp instantiates set_zero_extract1 {
	root (nonimmediate_operand:NULL:"", immediate_operand:NULL:"",
		immediate_operand:NULL:"", reg_or_0_operand:NULL:"");
}
{:
  "!TARGET_MIPS16"
{
  if (mips_expand_ins_as_unaligned_store (operands[0], operands[3],
					  INTVAL (operands[1]),
					  INTVAL (operands[2])))
    DONE;
  else if (mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),
			       INTVAL (operands[2])))
    {
      if (GET_MODE (operands[0]) == DImode)
        emit_insn (gen_insvdi (operands[0], operands[1], operands[2],
			       operands[3]));
      else
        emit_insn (gen_insvsi (operands[0], operands[1], operands[2],
			       operands[3]));
      DONE;
   }
   else
     FAIL;
}
:}

concrete insv<mode>.insn overrides insv.exp {
	root.1.mode:=GPR; root.1.1.mode:=GPR; root.1.2.mode:=SI;
	root.1.3.mode:=SI; root.2.mode:=GPR; allconstraints:=("+d","I","I","dJ");
	root.1.1.predicate:=register_operand;
}
{:
  "mips_use_ins_ext_p (operands[0], INTVAL (operands[1]),
		       INTVAL (operands[2]))"
  "<d>ins\t%0,%z3,%2,%1"
  [(set_attr "type"	"arith")
   (set_attr "mode"	"<MODE>")]
:}
{:
;; Combiner pattern for cins (clear and insert bit field).  We can
;; implement mask-and-shift-left operation with this.  Note that if
;; the upper bit of the mask is set in an SImode operation, the mask
;; itself will be sign-extended.  mask_low_and_shift_len will
;; therefore be greater than our threshold of 32.
:}
abstract set_and2_ashift1 extends set_and2 {
	root.2.1:=ashift;
}
concrete *cins<mode>.insn instantiates set_and2_ashift1 {
	root (register_operand:GPR:"=d", register_operand:GPR:"d",
		const_int_operand:GPR:"",const_int_operand:GPR:"");
	root.2.mode:=GPR; root.2.1.mode:=GPR;
}
{:
  "ISA_HAS_CINS
   && mask_low_and_shift_p (<MODE>mode, operands[3], operands[2], 32)"
{
  operands[3] =
    GEN_INT (mask_low_and_shift_len (<MODE>mode, operands[3], operands[2]));
  return "cins\t%0,%1,%2,%m3";
}
  [(set_attr "type"     "shift")
   (set_attr "mode"     "<MODE>")]
:}
{:
;; Unaligned word moves generated by the bit field patterns.
;;
;; As far as the rtl is concerned, both the left-part and right-part
;; instructions can access the whole field.  However, the real operand
;; refers to just the first or the last byte (depending on endianness).
;; We therefore use two memory operands to each instruction, one to
;; describe the rtl effect and one to use in the assembly output.
;;
;; Operands 0 and 1 are the rtl-level target and source respectively.
;; This allows us to use the standard length calculations for the "load"
;; and "store" type attributes.
:}

concrete mov_<load>l.insn instantiates set_unspec2 {
	root (register_operand:GPR:"=d", (memory_operand:BLK:"m",
		memory_operand:QI:"m", <UNSPEC_LOAD_LEFT>)); root.2.mode:=GPR;
}
{:
  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
  "<load>l\t%0,%2"
  [(set_attr "move_type" "load")
   (set_attr "mode" "<MODE>")]
:}

concrete mov_<load>r.insn instantiates set_unspec2 {
	root (register_operand:GPR:"=d", (memory_operand:BLK:"m",
		memory_operand:QI:"m",register_operand:GPR:"0",
		<UNSPEC_LOAD_RIGHT>)); root.2.mode:=GPR;
}
{:
  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[1])"
  "<load>r\t%0,%2"
  [(set_attr "move_type" "load")
   (set_attr "mode" "<MODE>")]
:}
concrete mov_<store>l.insn instantiates set_unspec2 {
	root (memory_operand:BLK:"=m", (reg_or_0_operand:GPR:"dJ", memory_operand:QI:"m",
		<UNSPEC_STORE_LEFT>)); root.2.mode:=BLK;
}
{:
  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
  "<store>l\t%z1,%2"
  [(set_attr "move_type" "store")
   (set_attr "mode" "<MODE>")]
:}
concrete mov_<store>r.insn instantiates set_unspec2 {
	root (memory_operand:BLK:"+m", (reg_or_0_operand:GPR:"dJ",
		memory_operand:QI:"m",duplicate 0,<UNSPEC_STORE_RIGHT>));
	root.2.mode:=BLK;
}
{:
  "!TARGET_MIPS16 && mips_mem_fits_mode_p (<MODE>mode, operands[0])"
  "<store>r\t%z1,%2"
  [(set_attr "move_type" "store")
   (set_attr "mode" "<MODE>")]
:}
{:
;; An instruction to calculate the high part of a 64-bit SYMBOL_ABSOLUTE.
;; The required value is:
;;
;;	(%highest(op1) << 48) + (%higher(op1) << 32) + (%hi(op1) << 16)
;;
;; which translates to:
;;
;;	lui	op0,%highest(op1)
;;	daddiu	op0,op0,%higher(op1)
;;	dsll	op0,op0,16
;;	daddiu	op0,op0,%hi(op1)
;;	dsll	op0,op0,16
;;
;; The split is deferred until after flow2 to allow the peephole2 below
;; to take effect.
:}
abstract set_high2 extends set {
	root.2:=high;
}
abstract set_lo_sum2 extends set {
	root.2:=lo_sum;
}
abstract set_high2_set_lo_sum2_set_ashift2_set_lo_sum2_set_ashift2 extends sequence {
	root.1:=set_high2; root.2:=set_lo_sum2; root.3:=set_ashift2; root.4:=set_lo_sum2;
	root.5:=set_ashift2;
}

concrete *lea_high64.insn_and_split instantiates.in set_high2 {
	root (register_operand:DI:"=d", absolute_symbolic_operand:DI:"");
	root.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && ABI_HAS_64BIT_SYMBOLS"
  "#"
  "&& epilogue_completed"
:}
instantiates.out set_high2_set_lo_sum2_set_ashift2_set_lo_sum2_set_ashift2 {
	root (duplicate 0, duplicate 2, duplicate 0,duplicate 0,duplicate 2,duplicate 0,
	duplicate 0,const_int:16,duplicate 0,duplicate 0,duplicate 3,duplicate 0,
	duplicate 0,const_int:16); root.1.2.mode:=DI; root.2.2.mode:=DI; root.3.2.mode:=DI;
	root.4.2.mode:=DI; root.5.2.mode:=DI;
}
cmd_spec.out
{:
{
  operands[2] = mips_unspec_address (operands[1], SYMBOL_64_HIGH);
  operands[3] = mips_unspec_address (operands[1], SYMBOL_64_MID);
}
  [(set_attr "length" "20")]
:}
{:
;; Use a scratch register to reduce the latency of the above pattern
;; on superscalar machines.  The optimized sequence is:
;;
;;	lui	op1,%highest(op2)
;;	lui	op0,%hi(op2)
;;	daddiu	op1,op1,%higher(op2)
;;	dsll32	op1,op1,0
;;	daddu	op1,op1,op0
:}
abstract set_high2_sequence extends sequence {
	root.1:=set_high2; root.2:=sequence;
}
abstract set_high2_set_high2_set_lo_sum2_set_ashift2_set_plus2 extends sequence {
	root.1:=set_high2; root.2:=set_high2; root.3:=set_lo_sum2; 
	root.4:=set_ashift2; root.5:=set_plus2;
}
concrete .peep2 instantiates.in set_high2_sequence{
	root (1=d_operand:DI:"", 2=absolute_symbolic_operand:DI:"", 0=DI:"d");
	root.1.2.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && ABI_HAS_64BIT_SYMBOLS"
:}
instantiates.out set_high2_set_high2_set_lo_sum2_set_ashift2_set_plus2 {
	root (duplicate 1, duplicate 3, duplicate 0, duplicate 4, duplicate 1,
	duplicate 1, duplicate 3, duplicate 1, duplicate 1, const_int:32,
	duplicate 1, duplicate 1, duplicate 0); root.1.2.mode:=DI;root.2.2.mode:=DI;
	root.3.2.mode:=DI;root.4.2.mode:=DI;root.5.2.mode:=DI;
}
cmd_spec.out
{:
{
  operands[3] = mips_unspec_address (operands[2], SYMBOL_64_HIGH);
  operands[4] = mips_unspec_address (operands[2], SYMBOL_64_LOW);
}
:}
{:
;; On most targets, the expansion of (lo_sum (high X) X) for a 64-bit
;; SYMBOL_ABSOLUTE X will take 6 cycles.  This next pattern allows combine
;; to merge the HIGH and LO_SUM parts of a move if the HIGH part is only
;; used once.  We can then use the sequence:
;;
;;	lui	op0,%highest(op1)
;;	lui	op2,%hi(op1)
;;	daddiu	op0,op0,%higher(op1)
;;	daddiu	op2,op2,%lo(op1)
;;	dsll32	op0,op0,0
;;	daddu	op0,op0,op2
;;
;; which takes 4 cycles on most superscalar targets.
:}
abstract set_clobber extends sequence {
	root.1:=set; root.2:=clobber;
}
abstract set_high2_x2_set_lo_sum2_x2_set_ashift2_set_plus2 extends sequence {
	root.1:=set_high2; root.2:=set_high2; root.3:=set_lo_sum2; root.4:=set_lo_sum2;
	root.5:=set_ashift2; root.6:=set_plus2;
}
concrete *lea64.insn_and_split instantiates.in set_clobber {
	root (0=register_operand:DI:"=d", absolute_symbolic_operand:DI:"",
		2=DI:"=&d");
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && ABI_HAS_64BIT_SYMBOLS && cse_not_expected"
  "#"
  "&& reload_completed"
:}
instantiates.out set_high2_x2_set_lo_sum2_x2_set_ashift2_set_plus2 {
	root (duplicate 0, duplicate 3, duplicate 2, duplicate 4, duplicate 0, duplicate 0,
	duplicate 3, duplicate 2, duplicate 2, duplicate 4, duplicate 0, duplicate 0,
	const_int:32,duplicate 0, duplicate 0,duplicate 2); 
	root.1.2.mode:=DI;root.2.2.mode:=DI;root.3.2.mode:=DI;
	root.4.2.mode:=DI;root.5.2.mode:=DI;root.6.2.mode:=DI;
}
cmd_spec.out
{:
{
  operands[3] = mips_unspec_address (operands[1], SYMBOL_64_HIGH);
  operands[4] = mips_unspec_address (operands[1], SYMBOL_64_LOW);
}
  [(set_attr "length" "24")]
:}
{:
;; Split HIGHs into:
;;
;;	li op0,%hi(sym)
;;	sll op0,16
;;
;; on MIPS16 targets.
:}

abstract set_unspec2_set_ashift2 extends sequence {
	root.1:=set_unspec2; root.2:=set_ashift2;
}

concrete .split instantiates.in set_high2 {
	root (d_operand:P:"", symbolic_operand_with_high:P:""); root.2.mode:=P;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed"
:}
instantiates.out set_unspec2_set_ashift2 {
	root (duplicate 0, (duplicate 1, <UNSPEC_UNSHIFTED_HIGH>), duplicate 0,
		duplicate 0, const_int:16);root.1.2.mode:=P; root.2.2.mode:=P;
}
cmd_spec.out
{:
:}

concrete *unshifted_high.insn instantiates set_unspec2 {
	root (d_operand:P:"=d", (symbolic_operand_with_high:P:"", <UNSPEC_UNSHIFTED_HIGH>));
	root.2.mode:=P;
}
{:
  ""
  "li\t%0,%h1"
  [(set_attr "extended_mips16" "yes")]
:}
{:
;; Insns to fetch a symbol from a big GOT.
:}
abstract set_high2_set_plus2 extends sequence {
	root.1:=set_high2; root.2:=set_plus2;
}

concrete *xgot_hi<mode>.insn_and_split instantiates.in set_high2 {
	root (register_operand:P:"=d", got_disp_operand:P:""); root.2.mode:=P;
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && TARGET_XGOT"
  "#"
  "&& reload_completed"
:}
instantiates.out set_high2_set_plus2 {
	root (duplicate 0, duplicate 2,duplicate 0, duplicate 0, duplicate 3);
	root.1.2.mode:=P; root.2.2.mode:=P;
}
cmd_spec.out
{:
{
  operands[2] = mips_unspec_address (operands[1], SYMBOL_GOTOFF_DISP);
  operands[3] = pic_offset_table_rtx;
}
  [(set_attr "got" "xgot_high")
   (set_attr "mode" "<MODE>")]
:}

concrete *xgot_lo<mode>.insn_and_split instantiates.in set_lo_sum2 {
	root (register_operand:P:"=d", register_operand:P:"d", 
		got_disp_operand:P:""); root.2.mode:=P;
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && TARGET_XGOT"
  "#"
  "&& reload_completed"
:}
instantiates.out set_unspec2 {
	root (duplicate 0, (duplicate 1, duplicate 3, <UNSPEC_LOAD_GOT>));
	root.2.mode:=P;
}
cmd_spec.out
{:
  { operands[3] = mips_unspec_address (operands[2], SYMBOL_GOTOFF_DISP); }
  [(set_attr "got" "load")
   (set_attr "mode" "<MODE>")]
:}

{:
;; Insns to fetch a symbol from a normal GOT.
:}
concrete *got_disp<mode>.insn_and_split instantiates.in set {
	root (register_operand:P:"=d", got_disp_operand:P:"");
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && !mips_split_p[SYMBOL_GOT_DISP]"
  "#"
  "&& reload_completed"
:}
instantiates.out set {
	root (duplicate 0, duplicate 2);
}
cmd_spec.out
{:
  { operands[2] = mips_got_load (NULL, operands[1], SYMBOL_GOTOFF_DISP); }
  [(set_attr "got" "load")
   (set_attr "mode" "<MODE>")]
:}
{:
;; Insns for loading the "page" part of a page/ofst address from the GOT.
:}

concrete *got_page<mode>.insn_and_split instantiates.in set_high2 {
	root (register_operand:P:"=d", got_page_ofst_operand:P:"");
	root.2.mode:=P;
}
cmd_spec.in
{:
  "TARGET_EXPLICIT_RELOCS && !mips_split_hi_p[SYMBOL_GOT_PAGE_OFST]"
  "#"
  "&& reload_completed"
:}
instantiates.out set {
	root (duplicate 0, duplicate 2);
}
cmd_spec.out
{:
  { operands[2] = mips_got_load (NULL, operands[1], SYMBOL_GOTOFF_PAGE); }
  [(set_attr "got" "load")
   (set_attr "mode" "<MODE>")]
:}
{:
;; Convenience expander that generates the rhs of a load_got<mode> insn.
:}
concrete unspec_got_<mode>.exp instantiates unspec {
	root ((NULL:P:"", NULL:P:"", <UNSPEC_LOAD_GOT>));
	root.1.mode:=Q;
}
{:
:}
{:
;; Lower-level instructions for loading an address from the GOT.
;; We could use MEMs, but an unspec gives more optimization
;; opportunities.
:}

concrete load_got<mode>.insn instantiates set_unspec2 {
	root (register_operand:P:"=d", (register_operand:P:"d",
		immediate_operand:P:"",<UNSPEC_LOAD_GOT>)); root.2.mode:=P;
}
{:
  ""
  "<load>\t%0,%R2(%1)"
  [(set_attr "got" "load")
   (set_attr "mode" "<MODE>")]
:}
{:
;; Instructions for adding the low 16 bits of an address to a register.
;; Operand 2 is the address: mips_print_operand works out which relocation
;; should be applied.
:}
concrete *low<mode>.insn instantiates set_lo_sum2 {
	root (register_operand:P:"=d", register_operand:P:"d",immediate_operand:P:"");
	root.2.mode:=P;
}
{:
  "!TARGET_MIPS16"
  "<d>addiu\t%0,%1,%R2"
  [(set_attr "alu_type" "add")
   (set_attr "mode" "<MODE>")]
:}

concrete *low<mode>_mips16.insn overrides *low<mode>.insn {
	root.2.1.constraint:="0";
}
{:
  "TARGET_MIPS16"
  "<d>addiu\t%0,%R2"
  [(set_attr "alu_type" "add")
   (set_attr "mode" "<MODE>")
   (set_attr "extended_mips16" "yes")]
:}
{:
;; Expose MIPS16 uses of the global pointer after reload if the function
;; is responsible for setting up the register itself.
:}

abstract set_const2_unspec1 extends set_const2 {
	root.2.1:=unspec;
}

concrete .split instantiates.in set_const2_unspec1 {
	root(d_operand:GPR:"", (const_int:0, <UNSPEC_GP>));
	root.2.mode:=GPR; root.2.1.mode:=GPR;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && TARGET_USE_GOT && reload_completed"
:}
instantiates.out set {
	root (duplicate 0, duplicate 1);
}
cmd_spec.out
{:
  { operands[1] = pic_offset_table_rtx; }
:}
{:
;; Allow combine to split complex const_int load sequences, using operand 2
;; to store the intermediate results.  See move_operand for details.
:}
concrete .split instantiates.in set_clobber {
	root (register_operand:GPR:"", splittable_const_int_operand:GPR:"", 
		register_operand:GPR:"");
}
cmd_spec.in
{:
  ""
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_move_integer (operands[2], operands[0], INTVAL (operands[1]));
  DONE;
}
:}

{:
;; Likewise, for symbolic operands.
:}
concrete .split instantiates.in set_clobber {
	root (register_operand:P:"", NULL:P:"", register_operand:P:""); 
}
cmd_spec.in
{:
  "mips_split_symbol (operands[2], operands[1], MAX_MACHINE_MODE, NULL)"
:}
instantiates.out set {
	root (duplicate 0, duplicate 3);
}
cmd_spec.out
{:
{
  mips_split_symbol (operands[2], operands[1],
		     MAX_MACHINE_MODE, &operands[3]);
}
:}
{:
;; 64-bit integer moves

;; Unlike most other insns, the move insns can't be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.
:}

concrete movdi.exp instantiates set {
	root (NULL:DI:"", NULL:DI:"");
}
{:
  ""
{
  if (mips_legitimize_move (DImode, operands[0], operands[1]))
    DONE;
}
:}

{:
;; For mips16, we need a special case to handle storing $31 into
;; memory, since we don't have a constraint to match $31.  This
;; instruction can be generated by save_restore_insns.
:}

concrete *mov<mode>_ra.insn instantiates set {
	root (stack_operand:GPR:"=m", reg(GPR:RETURN_ADDR_REGNUM));
}
{:
  "TARGET_MIPS16"
  "<store>\t$31,%0"
  [(set_attr "move_type" "store")
   (set_attr "mode" "<MODE>")]
:}
concrete *movdi_32bit.insn instantiates set {
	root (nonimmediate_operand:DI:"=d,d,d,m,*a,*d,*f,*f,*d,*m,*B*C*D,*B*C*D,*d,*m", 
		move_operand:DI:"d,i,m,d,*J*d,*a,*J*d,*m,*f,*f,*d,*m,*B*C*D,*B*C*D");
}
{:
  "!TARGET_64BIT && !TARGET_MIPS16
   && (register_operand (operands[0], DImode)
       || reg_or_0_operand (operands[1], DImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,const,load,store,mthilo,mfhilo,mtc,fpload,mfc,fpstore,mtc,fpload,mfc,fpstore")
   (set_attr "mode" "DI")]
:}
concrete *movdi_32bit_mips16.insn overrides *movdi_32bit.insn {
	allconstraints:=("=d,y,d,d,d,d,m,*d","d,d,y,K,N,m,d,*x");
}
{:
  "!TARGET_64BIT && TARGET_MIPS16
   && (register_operand (operands[0], DImode)
       || register_operand (operands[1], DImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,const,constN,load,store,mfhilo")
   (set_attr "mode" "DI")]
:}
concrete *movdi_64bit.insn overrides *movdi_32bit.insn {
	allconstraints:=("=d,d,e,d,m,*f,*f,*d,*m,*a,*d,*B*C*D,*B*C*D,*d,*m","d,U,T,m,dJ,*d*J,*m,*f,*f,*J*d,*a,*d,*m,*B*C*D,*B*C*D");
}
{:
  "TARGET_64BIT && !TARGET_MIPS16
   && (register_operand (operands[0], DImode)
       || reg_or_0_operand (operands[1], DImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,const,const,load,store,mtc,fpload,mfc,fpstore,mthilo,mfhilo,mtc,fpload,mfc,fpstore")
   (set_attr "mode" "DI")]
:}
concrete *movdi_64bit_mips16.insn overrides *movdi_32bit.insn {
	allconstraints:=("=d,y,d,d,d,d,d,d,m,*d","d,d,y,K,N,U,kf,m,d,*a");
}
{:
  "TARGET_64BIT && TARGET_MIPS16
   && (register_operand (operands[0], DImode)
       || register_operand (operands[1], DImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,const,constN,const,loadpool,load,store,mfhilo")
   (set_attr "mode" "DI")]
:}
{:
;; On the mips16, we can split ld $r,N($r) into an add and a load,
;; when the original load is a 4 byte instruction but the add and the
;; load are 2 2 byte instructions.
:}
abstract set_mem2_plus1 extends set_mem2 {
	root.2.1:=plus;
}
abstract set_plus2_set_mem2_plus1 extends sequence {
	root.1:=set_plus2; root.2:=set_mem2_plus1;
}

concrete .split instantiates.in set_mem2_plus1 {
	root (d_operand:DI:"", duplicate 0, const_int_operand:DI:"");
	root.2.mode:=DI; root.2.1.mode:=DI;
}
cmd_spec.in
{:
  "TARGET_64BIT && TARGET_MIPS16 && reload_completed
   && !TARGET_DEBUG_D_MODE
   && ((INTVAL (operands[1]) < 0
	&& INTVAL (operands[1]) >= -0x10)
       || (INTVAL (operands[1]) >= 32 * 8
	   && INTVAL (operands[1]) <= 31 * 8 + 0x8)
       || (INTVAL (operands[1]) >= 0
	   && INTVAL (operands[1]) < 32 * 8
	   && (INTVAL (operands[1]) & 7) != 0))"
:}
instantiates.out set_plus2_set_mem2_plus1 {
	root (duplicate 0, duplicate 0, duplicate 1, duplicate 0, duplicate 0,
		duplicate 2); root.1.2.mode:=DI; root.2.2.mode:=DI;
	root.2.2.1.mode:=DI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[1]);

  if (val < 0)
    operands[2] = const0_rtx;
  else if (val >= 32 * 8)
    {
      int off = val & 7;

      operands[1] = GEN_INT (0x8 + off);
      operands[2] = GEN_INT (val - off - 0x8);
    }
  else
    {
      int off = val & 7;

      operands[1] = GEN_INT (off);
      operands[2] = GEN_INT (val - off);
    }
}
:}

{:
;; 32-bit Integer moves

;; Unlike most other insns, the move insns can't be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.
:}
concrete mov<mode>.exp instantiates set {
	root (NULL:IMOVE32:"", NULL:IMOVE32:"");
}
{:
  ""
{
  if (mips_legitimize_move (<MODE>mode, operands[0], operands[1]))
    DONE;
}
:}

{:
;; The difference between these two is whether or not ints are allowed
;; in FP registers (off by default, use -mdebugh to enable).
:}

concrete *mov<mode>_internal.insn instantiates set {
	root (nonimmediate_operand:IMOVE32:"=d,d,e,d,m,*f,*f,*d,*m,*d,*z,*a,*d,*B*C*D,*B*C*D,*d,*m",
		move_operand:IMOVE32:"d,U,T,m,dJ,*d*J,*m,*f,*f,*z,*d,*J*d,*a,*d,*m,*B*C*D,*B*C*D");
}
{:
  "!TARGET_MIPS16
   && (register_operand (operands[0], <MODE>mode)
       || reg_or_0_operand (operands[1], <MODE>mode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,const,const,load,store,mtc,fpload,mfc,fpstore,mfc,mtc,mthilo,mfhilo,mtc,fpload,mfc,fpstore")
   (set_attr "mode" "SI")]
:}

concrete *mov<mode>_mips16.insn overrides *mov<mode>_internal.insn {
	allconstraints:=("=d,y,d,d,d,d,d,d,m,*d","d,d,y,K,N,U,kf,m,d,*a");
}
{:
  "TARGET_MIPS16
   && (register_operand (operands[0], <MODE>mode)
       || register_operand (operands[1], <MODE>mode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,const,constN,const,loadpool,load,store,mfhilo")
   (set_attr "mode" "SI")]
:}
{:
;; On the mips16, we can split lw $r,N($r) into an add and a load,
;; when the original load is a 4 byte instruction but the add and the
;; load are 2 2 byte instructions.
:}
abstract set_mem2_plus2 extends set {
	root.2:=mem; root.2.1:=plus;
}
concrete .split instantiates.in set_mem2_plus2 {
	root (d_operand:SI:"", duplicate 0, const_int_operand:SI:"");
	root.2.mode:=SI; root.2.1.mode:=SI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && ((INTVAL (operands[1]) < 0
	&& INTVAL (operands[1]) >= -0x80)
       || (INTVAL (operands[1]) >= 32 * 4
	   && INTVAL (operands[1]) <= 31 * 4 + 0x7c)
       || (INTVAL (operands[1]) >= 0
	   && INTVAL (operands[1]) < 32 * 4
	   && (INTVAL (operands[1]) & 3) != 0))"
:}
instantiates.out set_plus2_set_mem2_plus1 {
	root (duplicate 0, duplicate 0, duplicate 1, duplicate 0,
		duplicate 0, duplicate 2); root.1.2.mode:=SI; root.2.2.mode:=SI; root.2.2.1.mode:=SI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[1]);

  if (val < 0)
    operands[2] = const0_rtx;
  else if (val >= 32 * 4)
    {
      int off = val & 3;

      operands[1] = GEN_INT (0x7c + off);
      operands[2] = GEN_INT (val - off - 0x7c);
    }
  else
    {
      int off = val & 3;

      operands[1] = GEN_INT (off);
      operands[2] = GEN_INT (val - off);
    }
}
:}

{:
;; On the mips16, we can split a load of certain constants into a load
;; and an add.  This turns a 4 byte instruction into 2 2 byte
;; instructions.
:}

abstract set_set_plus2 extends sequence {
	root.1:=set; root.2:=set_plus2;
}

concrete .split instantiates.in set {
	root (d_operand:SI:"", const_int_operand:SI:"");
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && INTVAL (operands[1]) >= 0x100
   && INTVAL (operands[1]) <= 0xff + 0x7f"
:}
instantiates.out set_set_plus2 {
	root (duplicate 0, duplicate 1, duplicate 0, duplicate 0, duplicate 2);
	root.2.2.mode:=SI;
}
cmd_spec.out
{:
{
  int val = INTVAL (operands[1]);

  operands[1] = GEN_INT (0xff);
  operands[2] = GEN_INT (val - 0xff);
}
:}

{:
;; This insn handles moving CCmode values.  It's really just a
;; slightly simplified copy of movsi_internal2, with additional cases
;; to move a condition register to a general register and to move
;; between the general registers and the floating point registers.
:}

concrete movcc.insn instantiates set {
	root (nonimmediate_operand:CC:"=d,*d,*d,*m,*d,*f,*f,*f,*m", 
		general_operand:CC:"z,*d,*m,*d,*f,*d,*f,*m,*f");
}
{:
  "ISA_HAS_8CC && TARGET_HARD_FLOAT"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "lui_movf,move,load,store,mfc,mtc,fmove,fpload,fpstore")
   (set_attr "mode" "SI")]
:}

{:
;; Reload condition code registers.  reload_incc and reload_outcc
;; both handle moves from arbitrary operands into condition code
;; registers.  reload_incc handles the more common case in which
;; a source operand is constrained to be in a condition-code
;; register, but has not been allocated to one.
;;
;; Sometimes, such as in movcc, we have a CCmode destination whose
;; constraints do not include 'z'.  reload_outcc handles the case
;; when such an operand is allocated to a condition-code register.
;;
;; Note that reloads from a condition code register to some
;; other location can be done using ordinary moves.  Moving
;; into a GPR takes a single movcc, moving elsewhere takes
;; two.  We can leave these cases to the generic reload code.
:}
concrete reload_incc.exp instantiates set_clobber {
	root (fcc_reload_operand:CC:"=z", general_operand:CC:"", register_operand:TF:"=&f");
}
{:
  "ISA_HAS_8CC && TARGET_HARD_FLOAT"
{
  mips_expand_fcc_reload (operands[0], operands[1], operands[2]);
  DONE;
}
:}

concrete reload_outcc.exp overrides reload_incc.exp {
	root.1.2.predicate:=register_operand;
}
{:
  "ISA_HAS_8CC && TARGET_HARD_FLOAT"
{
  mips_expand_fcc_reload (operands[0], operands[1], operands[2]);
  DONE;
}
:}
{:
;; MIPS4 supports loading and storing a floating point register from
;; the sum of two general registers.  We use two versions for each of
;; these four instructions: one where the two general registers are
;; SImode, and one where they are DImode.  This is because general
;; registers will be in SImode when they hold 32-bit values, but,
;; since the 32-bit values are always sign extended, the [ls][wd]xc1
;; instructions will still work correctly.

;; ??? Perhaps it would be better to support these instructions by
;; modifying TARGET_LEGITIMATE_ADDRESS_P and friends.  However, since
;; these instructions can only be used to load and store floating
;; point registers, that would probably cause trouble in reload.
:}
concrete *<ANYF:loadx>_<P:mode>.insn instantiates set_mem2_plus1 {
	root (register_operand:ANYF:"=f", register_operand:P:"d", register_operand:P:"d");
	root.2.mode:=ANYF; root.2.1.mode:=P;
}
{:
  "ISA_HAS_FP4"
  "<ANYF:loadx>\t%0,%1(%2)"
  [(set_attr "type" "fpidxload")
   (set_attr "mode" "<ANYF:UNITMODE>")]
:}
abstract set_mem1_plus1 extends set_mem1 {
	root.1.1:=plus;
}
concrete *<ANYF:storex>_<P:mode>.insn instantiates set_mem1_plus1 {
	root (1=register_operand:P:"d", 2=register_operand:P:"d", 0=register_operand:ANYF:"f");
	root.1.mode:=ANYF; root.1.1.mode:=P;
}
{:
  "ISA_HAS_FP4"
  "<ANYF:storex>\t%0,%1(%2)"
  [(set_attr "type" "fpidxstore")
   (set_attr "mode" "<ANYF:UNITMODE>")]
:}
{:
;; Scaled indexed address load.
;; Per md.texi, we only need to look for a pattern with multiply in the
;; address expression, not shift.
:}
abstract set_mem2_plus1_mult1 extends set_mem2_plus1 {
	root.2.1.1:=mult;
}

concrete *lwxs.insn instantiates set_mem2_plus1_mult1 {
	root (register_operand:IMOVE32:"=d", register_operand:P:"d", const_int:4,
		register_operand:P:"d"); root.2.mode:=IMOVE32; root.2.1.mode:=P;root.2.1.1.mode:=P;
}
{:
  "ISA_HAS_LWXS"
  "lwxs\t%0,%1(%2)"
  [(set_attr "type"	"load")
   (set_attr "mode"	"SI")]
:}
{:
;; 16-bit Integer moves

;; Unlike most other insns, the move insns can't be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.
;; Unsigned loads are used because LOAD_EXTEND_OP returns ZERO_EXTEND.
:}
concrete movhi.exp instantiates set {
	root (NULL:HI:"", NULL:HI:"");
}
{:
  ""
{
  if (mips_legitimize_move (HImode, operands[0], operands[1]))
    DONE;
}
:}
concrete *movhi_internal.insn instantiates set {
	root (nonimmediate_operand:HI:"=d,d,d,m,*a,*d", move_operand:HI:"d,I,m,dJ,*d*J,*a");
}
{:
  "!TARGET_MIPS16
   && (register_operand (operands[0], HImode)
       || reg_or_0_operand (operands[1], HImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,const,load,store,mthilo,mfhilo")
   (set_attr "mode" "HI")]
:}
concrete *movhi_mips16.insn overrides *movhi_internal.insn {
	allconstraints:=("=d,y,d,d,d,d,m,*d","d,d,y,K,N,m,d,*a");
}
{:
  "TARGET_MIPS16
   && (register_operand (operands[0], HImode)
       || register_operand (operands[1], HImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,const,constN,load,store,mfhilo")
   (set_attr "mode" "HI")]
:}

{:
;; On the mips16, we can split lh $r,N($r) into an add and a load,
;; when the original load is a 4 byte instruction but the add and the
;; load are 2 2 byte instructions.
:}

concrete .split instantiates.in set_mem2_plus1 {
	root (d_operand:HI:"", duplicate 0, const_int_operand:SI:"");
	root.2.mode:=HI; root.2.1.mode:=SI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && ((INTVAL (operands[1]) < 0
	&& INTVAL (operands[1]) >= -0x80)
       || (INTVAL (operands[1]) >= 32 * 2
	   && INTVAL (operands[1]) <= 31 * 2 + 0x7e)
       || (INTVAL (operands[1]) >= 0
	   && INTVAL (operands[1]) < 32 * 2
	   && (INTVAL (operands[1]) & 1) != 0))"
:}
instantiates.out set_plus2_set_mem2_plus1 {
	root (duplicate 0, duplicate 0, duplicate 1, duplicate 0,
		duplicate 0,duplicate 2); root.1.2.mode:=SI; root.2.2.mode:=HI; root.2.2.1.mode:=SI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[1]);

  if (val < 0)
    operands[2] = const0_rtx;
  else if (val >= 32 * 2)
    {
      int off = val & 1;

      operands[1] = GEN_INT (0x7e + off);
      operands[2] = GEN_INT (val - off - 0x7e);
    }
  else
    {
      int off = val & 1;

      operands[1] = GEN_INT (off);
      operands[2] = GEN_INT (val - off);
    }
}
:}

{:
;; 8-bit Integer moves

;; Unlike most other insns, the move insns can't be split with
;; different predicates, because register spilling and other parts of
;; the compiler, have memoized the insn number already.
;; Unsigned loads are used because LOAD_EXTEND_OP returns ZERO_EXTEND.
:}
concrete movqi.exp instantiates set {
	root (NULL:QI:"", NULL:QI:"");
}
{:
  ""
{
  if (mips_legitimize_move (QImode, operands[0], operands[1]))
    DONE;
}
:}

concrete *movqi_internal.insn instantiates set {
	root (nonimmediate_operand:QI:"=d,d,d,m,*a,*d", move_operand:QI:"d,I,m,dJ,*d*J,*a");
}
{:
  "!TARGET_MIPS16
   && (register_operand (operands[0], QImode)
       || reg_or_0_operand (operands[1], QImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,const,load,store,mthilo,mfhilo")
   (set_attr "mode" "QI")]
:}
concrete *movqi_mips16.insn overrides *movqi_internal.insn {
	allconstraints:=("=d,y,d,d,d,d,m,*d","d,d,y,K,N,m,d,*a");
}
{:
  "TARGET_MIPS16
   && (register_operand (operands[0], QImode)
       || register_operand (operands[1], QImode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,const,constN,load,store,mfhilo")
   (set_attr "mode" "QI")]
:}
{:
;; On the mips16, we can split lb $r,N($r) into an add and a load,
;; when the original load is a 4 byte instruction but the add and the
;; load are 2 2 byte instructions.
:}
concrete .split instantiates.in set_mem2_plus1 {
	root (d_operand:QI:"", duplicate 0, const_int_operand:SI:"");
	root.2.mode:=QI; root.2.1.mode:=SI;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && ((INTVAL (operands[1]) < 0
	&& INTVAL (operands[1]) >= -0x80)
       || (INTVAL (operands[1]) >= 32
	   && INTVAL (operands[1]) <= 31 + 0x7f))"
:}
instantiates.out set_plus2_set_mem2_plus1
{
	root (duplicate 0, duplicate 0, duplicate 1, duplicate 0, 
		duplicate 0, duplicate 2); root.1.2.mode:=SI; root.2.2.mode:=QI;
	root.2.2.1.mode:=SI;
}
cmd_spec.out
{:
{
  HOST_WIDE_INT val = INTVAL (operands[1]);

  if (val < 0)
    operands[2] = const0_rtx;
  else
    {
      operands[1] = GEN_INT (0x7f);
      operands[2] = GEN_INT (val - 0x7f);
    }
}
:}

{:
;; 32-bit floating point moves
:}

concrete movsf.exp instantiates set {
	root (NULL:SF:"", NULL:SF:"");
}
{:
  ""
{
  if (mips_legitimize_move (SFmode, operands[0], operands[1]))
    DONE;
}
:}

concrete *movsf_hardfloat.insn instantiates set {
	root (nonimmediate_operand:SF:"=f,f,f,m,m,*f,*d,*d,*d,*m",
		move_operand:SF:"f,G,m,f,G,*d,*f,*G*d,*m,*d");
}
{:
  "TARGET_HARD_FLOAT
   && (register_operand (operands[0], SFmode)
       || reg_or_0_operand (operands[1], SFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store")
   (set_attr "mode" "SF")]
:}

concrete *movsf_softfloat.insn overrides *movsf_hardfloat.insn {
	allconstraints:=("=d,d,m","Gd,m,d");
}
{:
  "TARGET_SOFT_FLOAT && !TARGET_MIPS16
   && (register_operand (operands[0], SFmode)
       || reg_or_0_operand (operands[1], SFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,load,store")
   (set_attr "mode" "SF")]
:}

concrete *movsf_mips16.insn overrides *movsf_hardfloat.insn {
	allconstraints:= ("=d,y,d,d,m", "d,d,y,m,d");
}
{:
  "TARGET_MIPS16
   && (register_operand (operands[0], SFmode)
       || register_operand (operands[1], SFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,load,store")
   (set_attr "mode" "SF")]
:}
{:
;; 64-bit floating point moves
:}

concrete movdf.exp instantiates set {
	root (NULL:DF:"", NULL:DF:"");
}
{:
  ""
{
  if (mips_legitimize_move (DFmode, operands[0], operands[1]))
    DONE;
}
:}

concrete *movdf_hardfloat.insn instantiates set {
	root (nonimmediate_operand:DF:"=f,f,f,m,m,*f,*d,*d,*d,*m", 
		move_operand:DF:"f,G,m,f,G,*d,*f,*d*G,*m,*d");
}
{:
  "TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT
   && (register_operand (operands[0], DFmode)
       || reg_or_0_operand (operands[1], DFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store")
   (set_attr "mode" "DF")]
:}

concrete *movdf_softfloat.insn overrides *movdf_hardfloat.insn {
	allconstraints:=("=d,d,m","dG,m,dG");
}
{:
  "(TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT) && !TARGET_MIPS16
   && (register_operand (operands[0], DFmode)
       || reg_or_0_operand (operands[1], DFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,load,store")
   (set_attr "mode" "DF")]
:}

concrete *movdf_mips16.insn overrides *movdf_hardfloat.insn {
	allconstraints:=("=d,y,d,d,m","d,d,y,m,d");
}
{:
  "TARGET_MIPS16
   && (register_operand (operands[0], DFmode)
       || register_operand (operands[1], DFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "move,move,move,load,store")
   (set_attr "mode" "DF")]
:}

{:
;; 128-bit integer moves
:}

concrete movti.exp instantiates set {
	root (NULL:TI:"", NULL:TI:"");
}
{:
  "TARGET_64BIT"
{
  if (mips_legitimize_move (TImode, operands[0], operands[1]))
    DONE;
}
:}

concrete *movti.insn instantiates set {
	root (nonimmediate_operand:TI:"=d,d,d,m,*a,*d", 
		move_operand:TI:"d,i,m,dJ,*d*J,*a");
}
{:
  "TARGET_64BIT
   && !TARGET_MIPS16
   && (register_operand (operands[0], TImode)
       || reg_or_0_operand (operands[1], TImode))"
  "#"
  [(set_attr "move_type" "move,const,load,store,mthilo,mfhilo")
   (set_attr "mode" "TI")]
:}

concrete *movti_mips16.insn overrides *movti.insn {
	allconstraints:=("=d,y,d,d,d,d,m,*d","d,d,y,K,N,m,d,*a");
}
{:
  "TARGET_64BIT
   && TARGET_MIPS16
   && (register_operand (operands[0], TImode)
       || register_operand (operands[1], TImode))"
  "#"
  [(set_attr "move_type" "move,move,move,const,constN,load,store,mfhilo")
   (set_attr "mode" "TI")]
:}

{:
;; 128-bit floating point moves
:}

concrete movtf.exp instantiates set {
	root (NULL:TF:"", NULL:TF:"");
}
{:
  "TARGET_64BIT"
{
  if (mips_legitimize_move (TFmode, operands[0], operands[1]))
    DONE;
}
:}

{:
;; This pattern handles both hard- and soft-float cases.
:}
concrete *movtf.insn instantiates set {
	root (nonimmediate_operand:TF:"=d,d,m,f,d,f,m",
		move_operand:TF:"dG,m,dG,dG,f,m,f");
}
{:
  "TARGET_64BIT
   && !TARGET_MIPS16
   && (register_operand (operands[0], TFmode)
       || reg_or_0_operand (operands[1], TFmode))"
  "#"
  [(set_attr "move_type" "move,load,store,mtc,mfc,fpload,fpstore")
   (set_attr "mode" "TF")]
:}
concrete *movtf_mips16.insn overrides *movtf.insn {
	allconstraints:= ("=d,y,d,d,m", "d,d,y,m,d");
}
{:
  "TARGET_64BIT
   && TARGET_MIPS16
   && (register_operand (operands[0], TFmode)
       || register_operand (operands[1], TFmode))"
  "#"
  [(set_attr "move_type" "move,move,move,load,store")
   (set_attr "mode" "TF")]
:}
concrete .split instantiates.in set {
	root (nonimmediate_operand:MOVE64:"", move_operand:MOVE64:"");
}
cmd_spec.in
{:
  "reload_completed && !TARGET_64BIT
   && mips_split_64bit_move_p (operands[0], operands[1])"
:}
instantiates.out sequence
{
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_split_doubleword_move (operands[0], operands[1]);
  DONE;
}
:}

concrete .split instantiates.in set {
	root (nonimmediate_operand:MOVE128:"", move_operand:MOVE128:"");
}
cmd_spec.in
{:
  "TARGET_64BIT && reload_completed"
:}
instantiates.out sequence {
  root (const_int:0);
}
cmd_spec.out
{:
{
  mips_split_doubleword_move (operands[0], operands[1]);
  DONE;
}
:}
{:
;; When generating mips16 code, split moves of negative constants into
;; a positive "li" followed by a negation.
:}
abstract set_set_neg2 extends sequence {
	root.1:=set; root.2:=set_neg2;
}

concrete .split instantiates.in set {
	root (d_operand:NULL:"", const_int_operand:NULL:"");
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && INTVAL (operands[1]) < 0"
:}
instantiates.out set_set_neg2 {
	root (duplicate 2, duplicate 3, duplicate 2, duplicate 2);
	root.2.2.mode:=SI;
}
cmd_spec.out
{:
{
  operands[2] = gen_lowpart (SImode, operands[0]);
  operands[3] = GEN_INT (-INTVAL (operands[1]));
}
:}

{:
;; 64-bit paired-single floating point moves
:}

concrete movv2sf.exp instantiates set {
	root (NULL:V2SF:"", NULL:V2SF:"");
}
{:
  "TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT"
{
  if (mips_legitimize_move (V2SFmode, operands[0], operands[1]))
    DONE;
}
:}
concrete *movv2sf.insn instantiates set {
	root (nonimmediate_operand:V2SF:"=f,f,f,m,m,*f,*d,*d,*d,*m", 
		move_operand:V2SF:"f,YG,m,f,YG,*d,*f,*d*YG,*m,*d");
}
{:
  "TARGET_HARD_FLOAT
   && TARGET_PAIRED_SINGLE_FLOAT
   && (register_operand (operands[0], V2SFmode)
       || reg_or_0_operand (operands[1], V2SFmode))"
  { return mips_output_move (operands[0], operands[1]); }
  [(set_attr "move_type" "fmove,mtc,fpload,fpstore,store,mtc,mfc,move,load,store")
   (set_attr "mode" "DF")]
:}
{:
;; Extract the high part of a HI/LO value.  See mips_hard_regno_mode_ok_p
;; for the reason why we can't just use (reg:GPR HI_REGNUM).
;;
;; When generating VR4120 or VR4130 code, we use MACCHI and DMACCHI
;; instead of MFHI.  This avoids both the normal MIPS III hi/lo hazards
;; and the errata related to -mfix-vr4130.
:}
concrete mfhi<GPR:mode>_<HILO:mode>.insn instantiates set_unspec2 {
	root (register_operand:GPR:"=d", (hilo_operand:HILO:"x",<UNSPEC_MFHI>));
	root.2.mode:=GPR;
}
{:
  ""
  { return ISA_HAS_MACCHI ? "<GPR:d>macchi\t%0,%.,%." : "mfhi\t%0"; }
  [(set_attr "move_type" "mfhilo")
   (set_attr "mode" "<GPR:MODE>")]
:}
{:
;; Set the high part of a HI/LO value, given that the low part has
;; already been set.  See mips_hard_regno_mode_ok_p for the reason
;; why we can't just use (reg:GPR HI_REGNUM).
:}
concrete mthi<GPR:mode>_<HILO:mode>.insn instantiates set_unspec2 {
	root (register_operand:HILO:"=x", (reg_or_0_operand:GPR:"dJ",
		register_operand:GPR:"l", <UNSPEC_MTHI>)); root.2.mode:=HILO;
}
{:
  ""
  "mthi\t%z1"
  [(set_attr "move_type" "mthilo")
   (set_attr "mode" "SI")]
:}
{:
;; Emit a doubleword move in which exactly one of the operands is
;; a floating-point register.  We can't just emit two normal moves
;; because of the constraints imposed by the FPU register model;
;; see mips_cannot_change_mode_class for details.  Instead, we keep
;; the FPR whole and use special patterns to refer to each word of
;; the other operand.
:}
concrete move_doubleword_fpr<mode>.exp instantiates set
{
	root (NULL:SPLITF:"", NULL:SPLITF:"");
}
{:
  ""
{
  if (FP_REG_RTX_P (operands[0]))
    {
      rtx low = mips_subword (operands[1], 0);
      rtx high = mips_subword (operands[1], 1);
      emit_insn (gen_load_low<mode> (operands[0], low));
      if (TARGET_FLOAT64 && !TARGET_64BIT)
      	emit_insn (gen_mthc1<mode> (operands[0], high, operands[0]));
      else
	emit_insn (gen_load_high<mode> (operands[0], high, operands[0]));
    }
  else
    {
      rtx low = mips_subword (operands[0], 0);
      rtx high = mips_subword (operands[0], 1);
      emit_insn (gen_store_word<mode> (low, operands[1], const0_rtx));
      if (TARGET_FLOAT64 && !TARGET_64BIT)
	emit_insn (gen_mfhc1<mode> (high, operands[1]));
      else
	emit_insn (gen_store_word<mode> (high, operands[1], const1_rtx));
    }
  DONE;
}
:}
{:
;; Load the low word of operand 0 with operand 1.
:}
concrete load_low<mode>.insn instantiates set_unspec2 {
	root (register_operand:SPLITF:"=f,f", (general_operand:<HALFMODE>:"dJ,m",
		<UNSPEC_LOAD_LOW>));root.2.mode:=SPLITF;
}
{:
  "TARGET_HARD_FLOAT"
{
  operands[0] = mips_subword (operands[0], 0);
  return mips_output_move (operands[0], operands[1]);
}
  [(set_attr "move_type" "mtc,fpload")
   (set_attr "mode" "<HALFMODE>")]
:}
{:
;; Load the high word of operand 0 from operand 1, preserving the value
;; in the low word.
:}
concrete load_high<mode>.insn instantiates set_unspec2 {
	root (register_operand:SPLITF:"=f,f", (general_operand:<HALFMODE>:"dJ,m",
		register_operand:SPLITF:"0,0", <UNSPEC_LOAD_HIGH>));root.2.mode:=SPLITF;
}
{:
  "TARGET_HARD_FLOAT"
{
  operands[0] = mips_subword (operands[0], 1);
  return mips_output_move (operands[0], operands[1]);
}
  [(set_attr "move_type" "mtc,fpload")
   (set_attr "mode" "<HALFMODE>")]
:}
{:
;; Store one word of operand 1 in operand 0.  Operand 2 is 1 to store the
;; high word and 0 to store the low word.
:}
concrete store_word<mode>.insn instantiates set_unspec2 {
	root (nonimmediate_operand:<HALFMODE>:"=d,m", (register_operand:SPLITF:"f,f",
		const_int_operand:NULL:"",<UNSPEC_STORE_WORD>)); 
	root.2.mode:=<HALFMODE>;
}
{:
  "TARGET_HARD_FLOAT"
{
  operands[1] = mips_subword (operands[1], INTVAL (operands[2]));
  return mips_output_move (operands[0], operands[1]);
}
  [(set_attr "move_type" "mfc,fpstore")
   (set_attr "mode" "<HALFMODE>")]
:}
{:
;; Move operand 1 to the high word of operand 0 using mthc1, preserving the
;; value in the low word.
:}
concrete mthc1<mode>.insn instantiates set_unspec2 {
	root (register_operand:SPLITF:"=f", (reg_or_0_operand:<HALFMODE>:"dJ",
		register_operand:SPLITF:"0",<UNSPEC_MTHC1>)); root.2.mode:=SPLITF;
}
{:
  "TARGET_HARD_FLOAT && ISA_HAS_MXHC1"
  "mthc1\t%z1,%0"
  [(set_attr "move_type" "mtc")
   (set_attr "mode" "<HALFMODE>")]
:}
{:
;; Move high word of operand 1 to operand 0 using mfhc1.
:}
concrete mfhc1<mode>.insn instantiates set_unspec2 {
	root (register_operand:<HALFMODE>:"=d", (register_operand:SPLITF:"f",
		<UNSPEC_MFHC1>)); root.2.mode:=<HALFMODE>;
}
{:
  "TARGET_HARD_FLOAT && ISA_HAS_MXHC1"
  "mfhc1\t%0,%1"
  [(set_attr "move_type" "mfc")
   (set_attr "mode" "<HALFMODE>")]
:}
{:
;; Move a constant that satisfies CONST_GP_P into operand 0.
:}
concrete load_const_gp_<mode>.exp instantiates set_const2_unspec1 {
	root (register_operand:P:"=d",(const_int:0, <UNSPEC_GP>));
	root.2.mode:=P; root.2.1.mode:=P;
}
{:
:}

{:
;; Insn to initialize $gp for n32/n64 abicalls.  Operand 0 is the offset
;; of _gp from the start of this function.  Operand 1 is the incoming
;; function address.
:}
abstract set_x3 extends sequence {
	root.1:=set; root.2:=set; root.3:=set;
}
concrete loadgp_newabi_<mode>.insn_and_split instantiates.in set_unspec2 {
	root (register_operand:P:"=&d", (NULL:P:"", register_operand:P:"d",
		<UNSPEC_LOADGP>)); root.2.mode:=P;
}
cmd_spec.in
{:
  "mips_current_loadgp_style () == LOADGP_NEWABI"
  { return mips_must_initialize_gp_p () ? "#" : ""; }
  "&& mips_must_initialize_gp_p ()"
:}
instantiates.out set_x3 {
	root (duplicate 0, duplicate 3, duplicate 0, duplicate 4,
		duplicate 0, duplicate 5);
}
cmd_spec.out
{:
{
  operands[3] = gen_rtx_HIGH (Pmode, operands[1]);
  operands[4] = gen_rtx_PLUS (Pmode, operands[0], operands[2]);
  operands[5] = gen_rtx_LO_SUM (Pmode, operands[0], operands[1]);
}
  [(set_attr "type" "ghost")]
:}

{:
;; Likewise, for -mno-shared code.  Operand 0 is the __gnu_local_gp symbol.
:}
concrete loadgp_absolute_<mode>.insn_and_split instantiates.in set_unspec2 {
	root (register_operand:P:"=d", (NULL:P:"", <UNSPEC_LOADGP>));
	root.2.mode:=P;
}
cmd_spec.in
{:
  "mips_current_loadgp_style () == LOADGP_ABSOLUTE"
  { return mips_must_initialize_gp_p () ? "#" : ""; }
  "&& mips_must_initialize_gp_p ()"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_emit_move (operands[0], operands[1]);
  DONE;
}
  [(set_attr "type" "ghost")]
:}
{:
;; This blockage instruction prevents the gp load from being
;; scheduled after an implicit use of gp.  It also prevents
;; the load from being deleted as dead.
:}
concrete loadgp_blockage.insn instantiates unspec_volatile
{
	root ((reg(SI:28), <UNSPEC_BLOCKAGE>));
}
{:
  ""
  ""
  [(set_attr "type" "ghost")]
:}
{:
;; Initialize $gp for RTP PIC.  Operand 0 is the __GOTT_BASE__ symbol
;; and operand 1 is the __GOTT_INDEX__ symbol.
:}
abstract set_high2_set_unspec2_x2 extends sequence {
	root.1:=set_high2; root.2:=set_unspec2; root.3:=set_unspec2;
}
concrete loadgp_rtp_<mode>.insn_and_split instantiates.in set_unspec2 {
	root (register_operand:P:"=d", (symbol_ref_operand:P:"",
		symbol_ref_operand:P:"",<UNSPEC_LOADGP>)); root.2.mode:=P;
}
cmd_spec.in
{:
  "mips_current_loadgp_style () == LOADGP_RTP"
  { return mips_must_initialize_gp_p () ? "#" : ""; }
  "&& mips_must_initialize_gp_p ()"
:}
instantiates.out set_high2_set_unspec2_x2 {
	root (duplicate 0, duplicate 3, duplicate 0, (duplicate 0,
		duplicate 3, <UNSPEC_LOAD_GOT>), duplicate 0, (duplicate 0,
		duplicate 4, <UNSPEC_LOAD_GOT>));
	root.1.2.mode:=P; root.2.2.mode:=P; root.3.2.mode:=P;
}
cmd_spec.out
{:
{
  operands[3] = mips_unspec_address (operands[1], SYMBOL_ABSOLUTE);
  operands[4] = mips_unspec_address (operands[2], SYMBOL_HALF);
}
  [(set_attr "type" "ghost")]
:}
{:
;; Initialize the global pointer for MIPS16 code.  Operand 0 is the
;; global pointer and operand 1 is the MIPS16 register that holds
;; the required value.
:}
concrete copygp_mips16_<mode>.insn_and_split instantiates.in set_unspec2 {
	root (register_operand:P:"=y", (register_operand:P:"d", <UNSPEC_COPYGP>));
	root.2.mode:=P;
}
cmd_spec.in
{:
  "TARGET_MIPS16"
  { return mips_must_initialize_gp_p () ? "#" : ""; }
  "&& mips_must_initialize_gp_p ()"
:}
instantiates.out set {
	root (duplicate 0, duplicate 1);
}
cmd_spec.out
{:
  ""
  [(set_attr "type" "ghost")]
:}
{:
;; A placeholder for where the cprestore instruction should go,
;; if we decide we need one.  Operand 0 and operand 1 are as for
;; "cprestore".  Operand 2 is a register that holds the gp value.
;;
;; The "cprestore" pattern requires operand 2 to be pic_offset_table_rtx,
;; otherwise any register that holds the correct value will do.
:}
abstract set_unspec2_clobber extends sequence {
	root.1:=set_unspec2; root.2:=clobber;
}
concrete potential_cprestore_<mode>.insn_and_split instantiates.in set_unspec2_clobber {
	root (cprestore_save_slot_operand:P:"=X,X", (const_int_operand:P:"I,i",
		register_operand:P:"d,d", <UNSPEC_POTENTIAL_CPRESTORE>), 
		scratch_operand:P:"=X,&d"); root.1.2.mode:=P;
}
cmd_spec.in
{:
  "!TARGET_CPRESTORE_DIRECTIVE || operands[2] == pic_offset_table_rtx"
  { return mips_must_initialize_gp_p () ? "#" : ""; }
  "mips_must_initialize_gp_p ()"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_save_gp_to_cprestore_slot (operands[0], operands[1],
				  operands[2], operands[3]);
  DONE;
}
  [(set_attr "type" "ghost")]
:}
{:
;; Emit a .cprestore directive, which normally expands to a single store
;; instruction.  Operand 0 is a (possibly illegitimate) sp-based MEM
;; for the cprestore slot.  Operand 1 is the offset of the slot from
;; the stack pointer.  (This is redundant with operand 0, but it makes
;; things a little simpler.)
:}
concrete cprestore_<mode>.insn instantiates set_unspec2 {
	root (cprestore_save_slot_operand:P:"=X,X", (const_int_operand:P:"I,i",
		reg(P:28), <UNSPEC_CPRESTORE>));	root.2.mode:=P;
}
{:
  "TARGET_CPRESTORE_DIRECTIVE"
{
  if (mips_nomacro.nesting_level > 0 && which_alternative == 1)
    return ".set\tmacro\;.cprestore\t%1\;.set\tnomacro";
  else
    return ".cprestore\t%1";
}
  [(set_attr "type" "store")
   (set_attr "length" "4,12")]
:}
concrete use_cprestore_<mode>.insn instantiates set {
	root (reg(P:CPRESTORE_SLOT_REGNUM), cprestore_load_slot_operand:P:"");
}
{:
  ""
  ""
  [(set_attr "type" "ghost")]
:}
{:
;; Expand in-line code to clear the instruction cache between operand[0] and
;; operand[1].
:}
abstract sequence_sequence_x2 extends sequence {
	root.1:=sequence; root.2:=sequence;
}
concrete clear_cache.exp instantiates sequence_sequence_x2 {
	root ((pmode_register_operand:NULL:""), 
		(pmode_register_operand:NULL:""));
}
{:
  ""
  "
{
  if (TARGET_SYNCI)
    {
      mips_expand_synci_loop (operands[0], operands[1]);
      emit_insn (gen_sync ());
      emit_insn (PMODE_INSN (gen_clear_hazard, ()));
    }
  else if (mips_cache_flush_func && mips_cache_flush_func[0])
    {
      rtx len = gen_reg_rtx (Pmode);
      emit_insn (gen_sub3_insn (len, operands[1], operands[0]));
      MIPS_ICACHE_SYNC (operands[0], len);
    }
  DONE;
}"
:}
concrete sync.insn instantiates unspec_volatile {
	root ((const_int:0, <UNSPEC_SYNC>));
}
{:
  "GENERATE_SYNC"
  { return mips_output_sync (); }
:}
concrete synci.insn instantiates unspec_volatile {
	root ((pmode_register_operand:NULL:"d", <UNSPEC_SYNCI>));
}
{:
  "TARGET_SYNCI"
  "synci\t0(%0)"
:}
concrete rdhwr_synci_step_<mode>.insn instantiates set_unspec_volatile2 {
	root (register_operand:P:"=d", (const_int:1, <UNSPEC_RDHWR>));
}
{:
  "ISA_HAS_SYNCI"
  "rdhwr\t%0,$1"
:}
abstract unspec_volatile_clobber extends sequence {
	root.1:=unspec_volatile; root.2:=clobber;
}
concrete clear_hazard_<mode>.insn instantiates unspec_volatile_clobber {
	root ((const_int:0, <UNSPEC_CLEAR_HAZARD>), reg(P:RETURN_ADDR_REGNUM));
}
{:
  "ISA_HAS_SYNCI"
{
  return "%(%<bal\t1f\n"
         "\tnop\n"
         "1:\t<d>addiu\t$31,$31,12\n"
         "\tjr.hb\t$31\n"
         "\tnop%>%)";
}
  [(set_attr "length" "20")]
:}
{:
;; Cache operations for R4000-style caches.
:}
abstract set_mem1_unspec2 extends set_mem1 {
	root.2:=unspec;
}
concrete mips_cache.insn instantiates set_mem1_unspec2 {
	root (scratch, (const_int_operand:SI:"", address_operand:QI:"p",
		<UNSPEC_MIPS_CACHE>)); root.1.mode:=BLK; root.2.mode:=BLK;
}
{:
  "ISA_HAS_CACHE"
  "cache\t%X0,%a1"
:}
{:
;; Similar, but with the operands hard-coded to an R10K cache barrier
;; operation.  We keep the pattern distinct so that we can identify
;; cache operations inserted by -mr10k-cache-barrier=, and so that
;; the operation is never inserted into a delay slot.
:}
concrete r10k_cache_barrier.insn instantiates set_mem1_unspec2 {
	root (scratch, (const_int:0, <UNSPEC_R10K_CACHE_BARRIER>));
	root.1.mode:=BLK; root.2.mode:=BLK;
}
{:
  "ISA_HAS_CACHE"
  "cache\t0x14,0(%$)"
  [(set_attr "can_delay" "no")]
:}
{:

;; Block moves, see mips.c for more details.
;; Argument 0 is the destination
;; Argument 1 is the source
;; Argument 2 is the length
;; Argument 3 is the alignment
:}

abstract parallel_set_use_x2 extends parallel {
	root.1:=set; root.2:=use; root.3:=use;
}

concrete movmemsi.exp instantiates parallel_set_use_x2 {
	root (general_operand:BLK:"", general_operand:BLK:"", 
		NULL:SI:"", const_int_operand:SI:"");
}
{:
  "!TARGET_MIPS16 && !TARGET_MEMCPY"
{
  if (mips_expand_block_move (operands[0], operands[1], operands[2]))
    DONE;
  else
    FAIL;
}
:}
{:

;;
;;  ....................
;;
;;	SHIFTS
;;
;;  ....................
:}
abstract set_any_shift2 extends set{
	root.2:=any_shift;
}

concrete <optab><mode>3.exp instantiates set_any_shift2 {
	root (register_operand:GPR:"", register_operand:GPR:"", 
		arith_operand:SI:""); root.2.mode:=GPR;
}
{:
  ""
{
  /* On the mips16, a shift of more than 8 is a four byte instruction,
     so, for a shift between 8 and 16, it is just as fast to do two
     shifts of 8 or less.  If there is a lot of shifting going on, we
     may win in CSE.  Otherwise combine will put the shifts back
     together again.  This can be called by mips_function_arg, so we must
     be careful not to allocate a new register if we've reached the
     reload pass.  */
  if (TARGET_MIPS16
      && optimize
      && CONST_INT_P (operands[2])
      && INTVAL (operands[2]) > 8
      && INTVAL (operands[2]) <= 16
      && !reload_in_progress
      && !reload_completed)
    {
      rtx temp = gen_reg_rtx (<MODE>mode);

      emit_insn (gen_<optab><mode>3 (temp, operands[1], GEN_INT (8)));
      emit_insn (gen_<optab><mode>3 (operands[0], temp,
				     GEN_INT (INTVAL (operands[2]) - 8)));
      DONE;
    }
}
:}
concrete *<optab><mode>3.insn overrides <optab><mode>3.exp {
	allconstraints:=("=d", "d", "dI");
}
{:
  "!TARGET_MIPS16"
{
  if (CONST_INT_P (operands[2]))
    operands[2] = GEN_INT (INTVAL (operands[2])
			   & (GET_MODE_BITSIZE (<MODE>mode) - 1));

  return "<d><insn>\t%0,%1,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "<MODE>")]
:}

abstract set_sign_extend2_any_shift1 extends set_sign_extend2 {
	root.2.1:=any_shift;
}

concrete *<optab>si3_extend.insn instantiates set_sign_extend2_any_shift1 {
	root (register_operand:DI:"=d", register_operand:SI:"d", 
		arith_operand:SI:"dI"); root.2.mode:=DI; root.2.1.mode:=SI;
}
{:
  "TARGET_64BIT && !TARGET_MIPS16"
{
  if (CONST_INT_P (operands[2]))
    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);

  return "<insn>\t%0,%1,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "SI")]
:}
concrete *<optab>si3_mips16.insn overrides <optab><mode>3.exp {
	GPR->SI; allconstraints:=("=d,d","0,d","d,I");
}
{:
  "TARGET_MIPS16"
{
  if (which_alternative == 0)
    return "<insn>\t%0,%2";

  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x1f);
  return "<insn>\t%0,%1,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "SI")
   (set_attr_alternative "length"
		[(const_int 4)
		 (if_then_else (match_operand 2 "m16_uimm3_b")
			       (const_int 4)
			       (const_int 8))])]
:}
{:
;; We need separate DImode MIPS16 patterns because of the irregularity
;; of right shifts.
:}

concrete *ashldi3_mips16.insn instantiates set_ashift2 {
	root (register_operand:DI:"=d,d", register_operand:DI:"0,d", 
		arith_operand:SI:"d,I"); root.2.mode:=DI;
}
{:
  "TARGET_64BIT && TARGET_MIPS16"
{
  if (which_alternative == 0)
    return "dsll\t%0,%2";

  operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);
  return "dsll\t%0,%1,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "DI")
   (set_attr_alternative "length"
		[(const_int 4)
		 (if_then_else (match_operand 2 "m16_uimm3_b")
			       (const_int 4)
			       (const_int 8))])]
:}
concrete *ashrdi3_mips16.insn instantiates set_ashiftrt2 {
	root (register_operand:DI:"=d,d", register_operand:DI:"0,0", 
		arith_operand:SI:"d,I"); root.2.mode:=DI;
}
{:
  "TARGET_64BIT && TARGET_MIPS16"
{
  if (CONST_INT_P (operands[2]))
    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);

  return "dsra\t%0,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "DI")
   (set_attr_alternative "length"
		[(const_int 4)
		 (if_then_else (match_operand 2 "m16_uimm3_b")
			       (const_int 4)
			       (const_int 8))])]
:}
concrete *lshrdi3_mips16.insn instantiates set_lshiftrt2 {
	root (register_operand:DI:"=d,d", register_operand:DI:"0,0",
		arith_operand:SI:"d,I"); root.2.mode:=DI;
}
{:
  "TARGET_64BIT && TARGET_MIPS16"
{
  if (CONST_INT_P (operands[2]))
    operands[2] = GEN_INT (INTVAL (operands[2]) & 0x3f);

  return "dsrl\t%0,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "DI")
   (set_attr_alternative "length"
		[(const_int 4)
		 (if_then_else (match_operand 2 "m16_uimm3_b")
			       (const_int 4)
			       (const_int 8))])]
:}
{:
;; On the mips16, we can split a 4 byte shift into 2 2 byte shifts.
:}
abstract set_any_shift2_x2 extends sequence {
	root.1:=set_any_shift2; root.2:=set_any_shift2;
}
concrete .split instantiates.in set_any_shift2 {
	root (d_operand:GPR:"", d_operand:GPR:"", const_int_operand:GPR:"");
	root.2.mode:=GPR;
}
cmd_spec.in
{:
  "TARGET_MIPS16 && reload_completed && !TARGET_DEBUG_D_MODE
   && INTVAL (operands[2]) > 8
   && INTVAL (operands[2]) <= 16"
:}
instantiates.out set_any_shift2_x2 {
	root (duplicate 0, duplicate 1, const_int:8, duplicate 0,
		duplicate 0, duplicate 2); root.1.2.mode:=GPR; root.2.2.mode:=GPR;
}
cmd_spec.out
{:
  { operands[2] = GEN_INT (INTVAL (operands[2]) - 8); }
:}

{:
;; If we load a byte on the mips16 as a bitfield, the resulting
;; sequence of instructions is too complicated for combine, because it
;; involves four instructions: a load, a shift, a constant load into a
;; register, and an and (the key problem here is that the mips16 does
;; not have and immediate).  We recognize a shift of a load in order
;; to make it simple enough for combine to understand.
;;
;; The length here is the worst case: the length of the split version
;; will be more accurate.

(define_insn_and_split ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(lshiftrt:SI (match_operand:SI 1 "memory_operand" "m")
		     (match_operand:SI 2 "immediate_operand" "I")))]
  "TARGET_MIPS16"
  "#"
  ""
  [(set (match_dup 0) (match_dup 1))
   (set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 2)))]
  ""
  [(set_attr "type"	"load")
   (set_attr "mode"	"SI")
   (set_attr "length"	"16")])
:}

abstract set_rotatert2 extends set {
	root.2:=rotatert;
}

concrete rotr<mode>3.insn instantiates set_rotatert2 {
	root (register_operand:GPR:"=d", register_operand:GPR:"d", 
		arith_operand:SI:"dI"); root.2.mode:=GPR;
}
{:
  "ISA_HAS_ROR"
{
  if (CONST_INT_P (operands[2]))
    gcc_assert (INTVAL (operands[2]) >= 0
		&& INTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode));

  return "<d>ror\t%0,%1,%2";
}
  [(set_attr "type" "shift")
   (set_attr "mode" "<MODE>")]
:}
{:

;;
;;  ....................
;;
;;	CONDITIONAL BRANCHES
;;
;;  ....................

;; Conditional branches on floating-point equality tests.
:}
abstract set_if_then_else2_match_operator1_label_ref2 extends set_if_then_else2 {
	root.2.1:=match_operator; root.2.2:=label_ref;
}

concrete *branch_fp.insn instantiates set_if_then_else2_match_operator1_label_ref2 {
	root (pc, (1=equality_operator, 2=register_operand:CC:"z", const_int:0), 0=NULL:NULL:"", pc);
}
{:
  "TARGET_HARD_FLOAT"
{
  return mips_output_conditional_branch (insn, operands,
					 MIPS_BRANCH ("b%F1", "%Z2%0"),
					 MIPS_BRANCH ("b%W1", "%Z2%0"));
}
  [(set_attr "type" "branch")]
:}
abstract set_if_then_else2_match_operator1_label_ref3 extends set_if_then_else2 {
	root.2.1:=match_operator; root.2.3:=label_ref;
}
concrete *branch_fp_inverted.insn instantiates set_if_then_else2_match_operator1_label_ref3 {
	root (pc, (1=equality_operator, 2=register_operand:CC:"z", const_int:0),pc, 0=NULL:NULL:"");
}
{:
  "TARGET_HARD_FLOAT"
{
  return mips_output_conditional_branch (insn, operands,
					 MIPS_BRANCH ("b%W1", "%Z2%0"),
					 MIPS_BRANCH ("b%F1", "%Z2%0"));
}
  [(set_attr "type" "branch")]
:}

{:
;; Conditional branches on ordered comparisons with zero.
:}

concrete *branch_order<mode>.insn instantiates set_if_then_else2_match_operator1_label_ref2 {
	root (pc, (1=order_operator,2=register_operand:GPR:"d", const_int:0),0=NULL:NULL:"",pc);
}
{:
  "!TARGET_MIPS16"
  { return mips_output_order_conditional_branch (insn, operands, false); }
  [(set_attr "type" "branch")]
:}

concrete *branch_order<mode>_inverted.insn instantiates set_if_then_else2_match_operator1_label_ref3 {
	root (pc, (1=order_operator,2=register_operand:GPR:"d", const_int:0), pc,
		0=NULL:NULL:"");
}
{:
  "!TARGET_MIPS16"
  { return mips_output_order_conditional_branch (insn, operands, true); }
  [(set_attr "type" "branch")]
:}
{:
;; Conditional branch on equality comparison.
:}
concrete *branch_equality<mode>.insn instantiates set_if_then_else2_match_operator1_label_ref2 {
	root (pc, (1=equality_operator, 2=register_operand:GPR:"d", 3=reg_or_0_operand:GPR:"dJ"),
		0=NULL:NULL:"", pc);
}
{:
  "!TARGET_MIPS16"
{
  return mips_output_conditional_branch (insn, operands,
					 MIPS_BRANCH ("b%C1", "%2,%z3,%0"),
					 MIPS_BRANCH ("b%N1", "%2,%z3,%0"));
}
  [(set_attr "type" "branch")]
:}
concrete *branch_equality<mode>_inverted.insn instantiates set_if_then_else2_match_operator1_label_ref3 {
	root (pc, (1=equality_operator, 2=register_operand:GPR:"d", 3=reg_or_0_operand:GPR:"dJ"),
		pc, 0=NULL:NULL:"");
}
{:
  "!TARGET_MIPS16"
{
  return mips_output_conditional_branch (insn, operands,
					 MIPS_BRANCH ("b%N1", "%2,%z3,%0"),
					 MIPS_BRANCH ("b%C1", "%2,%z3,%0"));
}
  [(set_attr "type" "branch")]
:}
{:
;; MIPS16 branches
:}
abstract set_if_then_else2_match_operator1 extends set_if_then_else2 {
	root.2.1:=match_operator;
}
concrete *branch_equality<mode>_mips16.insn instantiates set_if_then_else2_match_operator1 {
	root (pc, (0=equality_operator, register_operand:GPR:"d,t", const_int:0), 
		pc_or_label_operand:NULL:"", pc_or_label_operand:NULL:""); 
}
{:
  "TARGET_MIPS16"
{
  if (operands[2] != pc_rtx)
    {
      if (which_alternative == 0)
	return "b%C0z\t%1,%2";
      else
	return "bt%C0z\t%2";
    }
  else
    {
      if (which_alternative == 0)
	return "b%N0z\t%1,%3";
      else
	return "bt%N0z\t%3";
    }
}
  [(set_attr "type" "branch")]
:}
concrete cbranch<mode>4.exp instantiates set_if_then_else2_match_operator1_label_ref2 {
	root (pc, (0=comparison_operator, 1=register_operand:GPR:"", 2=nonmemory_operand:GPR:""),
		3=NULL:NULL:"", pc);
}
{:
  ""
{
  mips_expand_conditional_branch (operands);
  DONE;
}
:}

concrete cbranch<mode>4.exp instantiates set_if_then_else2_match_operator1_label_ref2 {
	root (pc, (0=comparison_operator, 1=register_operand:SCALARF:"", 
		2=register_operand:SCALARF:""), 3=NULL:NULL:"",pc);
}
{:
  ""
{
  mips_expand_conditional_branch (operands);
  DONE;
}
:}

{:
;; Used to implement built-in functions.
:}
abstract set_if_then_else2_label_ref2 extends set_if_then_else2 {
	root.2.2:=label_ref;
}
concrete condjump.exp instantiates set_if_then_else2_label_ref2 {
	root(pc, NULL:NULL:"",NULL:NULL:"",pc);
}
{:
:}

{:
;; Branch if bit is set/clear.
:}

abstract set_if_then_else2_equality_op1_zero_extract1_label_ref2 extends set_if_then_else2 {
	root.2.1:=equality_op; root.2.1.1:=zero_extract; root.2.2:=label_ref;
}

concrete *branch_bit<bbv><mode>.insn instantiates set_if_then_else2_equality_op1_zero_extract1_label_ref2 {
	root (pc, 1=register_operand:GPR:"d", const_int:1, 2=const_int_operand:NULL:"", 
		const_int:0, 0=NULL:NULL:"", pc); root.2.1.1.mode:=GPR;
}
{:
  "ISA_HAS_BBIT && UINTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode)"
{
  return
    mips_output_conditional_branch (insn, operands,
				    MIPS_BRANCH ("bbit<bbv>", "%1,%2,%0"),
				    MIPS_BRANCH ("bbit<bbinv>", "%1,%2,%0"));
}
  [(set_attr "type"	     "branch")
   (set_attr "branch_likely" "no")]
:}

abstract set_if_then_else2_equality_op1_zero_extract1_label_ref3 extends set_if_then_else2 {
	root.2.1:=equality_op; root.2.1.1:=zero_extract; root.2.3:=label_ref;
}

concrete *branch_bit<bbv><mode>_inverted.insn instantiates
set_if_then_else2_equality_op1_zero_extract1_label_ref3 {
	root (pc, 1=register_operand:GPR:"d", const_int:1, 2=const_int_operand:NULL:"", 
	const_int:0, pc ,0=NULL:NULL:"");
}
{:
  "ISA_HAS_BBIT && UINTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode)"
{
  return
    mips_output_conditional_branch (insn, operands,
				    MIPS_BRANCH ("bbit<bbinv>", "%1,%2,%0"),
				    MIPS_BRANCH ("bbit<bbv>", "%1,%2,%0"));
}
  [(set_attr "type"	     "branch")
   (set_attr "branch_likely" "no")]
:}
{:

;;
;;  ....................
;;
;;	SETTING A REGISTER FROM A COMPARISON
;;
;;  ....................

;; Destination is always set in SI mode.
:}

concrete cstore<mode>4.exp instantiates set_match_operator2 {
	root (register_operand:SI:"", (1=mips_cstore_operator, register_operand:GPR:"",
		nonmemory_operand:GPR:"")); root.2.mode:=SI;
}
{:
  ""
{
  mips_expand_scc (operands);
  DONE;
}
:}

concrete *seq_zero_<GPR:mode><GPR2:mode>.insn instantiates set_eq2 {
	root (register_operand:GPR2:"=d", register_operand:GPR:"d", const_int:0);
	root.2.mode:=GPR2;
}
{:
  "!TARGET_MIPS16 && !ISA_HAS_SEQ_SNE"
  "sltu\t%0,%1,1"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
concrete *seq_zero_<GPR:mode><GPR2:mode>_mips16.insn overrides *seq_zero_<GPR:mode><GPR2:mode>.insn {
	allconstraints:= ("=t","d");
}
{:
  "TARGET_MIPS16 && !ISA_HAS_SEQ_SNE"
  "sltu\t%1,1"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
{:
;; Generate sltiu unless using seq results in better code.
:}

concrete *seq_<GPR:mode><GPR2:mode>_seq.insn instantiates set_eq2 {
	root (register_operand:GPR2:"=d,d,d", register_operand:GPR:"%d,d,d",
		reg_imm10_operand:GPR:"d,J,YB"); root.2.mode:=GPR2;
}
{:
  "ISA_HAS_SEQ_SNE"
  "@
   seq\t%0,%1,%2
   sltiu\t%0,%1,1
   seqi\t%0,%1,%2"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *sne_zero_<GPR:mode><GPR2:mode>.insn instantiates set_ne2 {
	root (register_operand:GPR2:"=d", register_operand:GPR:"d",
		const_int:0); root.2.mode:=GPR2;
}
{:
  "!TARGET_MIPS16 && !ISA_HAS_SEQ_SNE"
  "sltu\t%0,%.,%1"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
{:
;; Generate sltu unless using sne results in better code.
:}
concrete *sne_<GPR:mode><GPR2:mode>_sne.insn instantiates set_ne2 {
	root (register_operand:GPR2:"=d,d,d", register_operand:GPR:"%d,d,d",
		reg_imm10_operand:GPR:"d,J,YB"); root.2.mode:=GPR2;
}
{:
  "ISA_HAS_SEQ_SNE"
  "@
   sne\t%0,%1,%2
   sltu\t%0,%.,%1
   snei\t%0,%1,%2"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
abstract set_any_gt2 extends set {
	root.2:=any_gt;
}
abstract set_any_ge2 extends set {
	root.2:=any_ge;
}
abstract set_any_lt2 extends set {
	root.2:=any_lt;
}
abstract set_any_le2 extends set {
	root.2:=any_le;
}
concrete *sgt<u>_<GPR:mode><GPR2:mode>.insn instantiates set_any_gt2 {
	root (register_operand:GPR2:"=d", register_operand:GPR:"d",
		reg_or_0_operand:GPR:"dJ"); root.2.mode:=GPR2;
}
{:
  "!TARGET_MIPS16"
  "slt<u>\t%0,%z2,%1"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *sgt<u>_<GPR:mode><GPR2:mode>_mips16.insn overrides *sgt<u>_<GPR:mode><GPR2:mode>.insn {
	root.2.2.predicate:=register_operand; allconstraints:=("=t","d","d");
}
{:
  "TARGET_MIPS16"
  "slt<u>\t%2,%1"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}

concrete *sge<u>_<GPR:mode><GPR2:mode>.insn instantiates set_any_ge2 {
	root (register_operand:GPR2:"=d", register_operand:GPR:"d", const_int:1);
	root.2.mode:=GPR2;
}
{:
  "!TARGET_MIPS16"
  "slt<u>\t%0,%.,%1"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
concrete *slt<u>_<GPR:mode><GPR2:mode>.insn instantiates set_any_lt2 {
	root (register_operand:GPR2:"=d", register_operand:GPR:"d", arith_operand:GPR:"dI");
	root.2.mode:=GPR2;
}
{:
  "!TARGET_MIPS16"
  "slt<u>\t%0,%1,%2"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
concrete *slt<u>_<GPR:mode><GPR2:mode>_mips16.insn overrides *slt<u>_<GPR:mode><GPR2:mode>.insn {
	allconstraints:=("=t,t","d,d","d,I");
}
{:
  "TARGET_MIPS16"
  "slt<u>\t%1,%2"
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")
   (set_attr_alternative "length"
		[(const_int 4)
		 (if_then_else (match_operand 2 "m16_uimm8_1")
			       (const_int 4)
			       (const_int 8))])]
:}
concrete *sle<u>_<GPR:mode><GPR2:mode>.insn instantiates set_any_le2 {
	root (register_operand:GPR2:"=d", register_operand:GPR:"d", sle_operand:GPR:"");
	root.2.mode:=GPR2;
}
{:  
  "!TARGET_MIPS16"
{
  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);
  return "slt<u>\t%0,%1,%2";
}
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")]
:}
concrete *sle<u>_<GPR:mode><GPR2:mode>_mips16.insn overrides *sle<u>_<GPR:mode><GPR2:mode>.insn {
	allconstraints:= ("=t","d","");
}
{:
  "TARGET_MIPS16"
{
  operands[2] = GEN_INT (INTVAL (operands[2]) + 1);
  return "slt<u>\t%1,%2";
}
  [(set_attr "type" "slt")
   (set_attr "mode" "<GPR:MODE>")
   (set (attr "length") (if_then_else (match_operand 2 "m16_uimm8_m1_1")
				      (const_int 4)
				      (const_int 8)))]
:}
{:

;;
;;  ....................
;;
;;	FLOATING POINT COMPARISONS
;;
;;  ....................
:}

abstract set_fcond2 extends set {
	root.2:=fcond;
}

abstract set_swapped_fcond2 extends set {
	root.2:=swapped_fcond;
}

concrete s<code>_<mode>.insn instantiates set_fcond2 {
	root (register_operand:CC:"=z", register_operand:SCALARF:"f",
		register_operand:SCALARF:"f"); root.2.mode:=CC;
}
{:
  ""
  "c.<fcond>.<fmt>\t%Z0%1,%2"
  [(set_attr "type" "fcmp")
   (set_attr "mode" "FPSW")]
:}

concrete s<code>_<mode>.insn instantiates set_swapped_fcond2 {
	root (register_operand:CC:"=z", register_operand:SCALARF:"f",
		register_operand:SCALARF:"f"); root.2.mode:=CC;
}
{:
  ""
  "c.<swapped_fcond>.<fmt>\t%Z0%2,%1"
  [(set_attr "type" "fcmp")
   (set_attr "mode" "FPSW")]
:}
{:

;;
;;  ....................
;;
;;	UNCONDITIONAL BRANCHES
;;
;;  ....................

;; Unconditional branches.
:}
concrete jump.exp instantiates set_label_ref2 {
	root (pc, NULL:NULL:"");
}
{:
:}
concrete *jump_absolute.insn instantiates set_label_ref2 {
	root (pc, NULL:NULL:"");
}
{:
  "!TARGET_MIPS16 && TARGET_ABSOLUTE_JUMPS"
  { return MIPS_ABSOLUTE_JUMP ("%*j\t%l0%/"); }
  [(set_attr "type" "jump")]
:}
concrete *jump_pic.insn instantiates set_label_ref2 {
	root (pc, NULL:NULL:"");
}
{:
  "!TARGET_MIPS16 && !TARGET_ABSOLUTE_JUMPS"
{
  if (get_attr_length (insn) <= 8)
    return "%*b\t%l0%/";
  else
    {
      mips_output_load_label (operands[0]);
      return "%*jr\t%@%/%]";
    }
}
  [(set_attr "type" "branch")]
:}
{:
;; We need a different insn for the mips16, because a mips16 branch
;; does not have a delay slot.
:}
concrete *jump_mips16.insn instantiates set_label_ref2 {
	root (pc, NULL:NULL:"");
}
{:
  "TARGET_MIPS16"
  "b\t%l0"
  [(set_attr "type" "branch")]
:}
concrete indirect_jump.exp instantiates set {
	root (pc, register_operand:NULL:"");
}
{:
  ""
{
  operands[0] = force_reg (Pmode, operands[0]);
  emit_jump_insn (PMODE_INSN (gen_indirect_jump, (operands[0])));
  DONE;
}
:}
concrete indirect_jump_<mode>.insn overrides indirect_jump.insn {
	root.2:=register_operand:P:"d";
}
{:
  ""
  "%*j\t%0%/"
  [(set_attr "type" "jump")
   (set_attr "mode" "none")]
:}
abstract set_use_label_ref extends sequence {
	root.1:=set; root.2:=use; root.2.1:=label_ref;
}
concrete tablejump.exp instantiates set_use_label_ref {
	root (pc, register_operand:NULL:"", NULL:NULL:"");
}
{:
  ""
{
  if (TARGET_MIPS16_SHORT_JUMP_TABLES)
    operands[0] = expand_binop (Pmode, add_optab,
				convert_to_mode (Pmode, operands[0], false),
				gen_rtx_LABEL_REF (Pmode, operands[1]),
				0, 0, OPTAB_WIDEN);
  else if (TARGET_GPWORD)
    operands[0] = expand_binop (Pmode, add_optab, operands[0],
				pic_offset_table_rtx, 0, 0, OPTAB_WIDEN);
  else if (TARGET_RTP_PIC)
    {
      /* When generating RTP PIC, we use case table entries that are relative
	 to the start of the function.  Add the function's address to the
	 value we loaded.  */
      rtx start = get_hard_reg_initial_val (Pmode, PIC_FUNCTION_ADDR_REGNUM);
      operands[0] = expand_binop (ptr_mode, add_optab, operands[0],
				  start, 0, 0, OPTAB_WIDEN);
    }

  emit_jump_insn (PMODE_INSN (gen_tablejump, (operands[0], operands[1])));
  DONE;
}
:}

concrete tablejump_<mode>.insn overrides tablejump.exp {
	root.1.2:=register_operand:P:"d";
}
{:
  ""
  "%*j\t%0%/"
  [(set_attr "type" "jump")
   (set_attr "mode" "none")]
:}
{:
;; For TARGET_USE_GOT, we save the gp in the jmp_buf as well.
;; While it is possible to either pull it off the stack (in the
;; o32 case) or recalculate it given t9 and our target label,
;; it takes 3 or 4 insns to do so.
:}
concrete builtin_setjmp_setup.exp instantiates use {
	root (register_operand:NULL:"");
}
{:
  "TARGET_USE_GOT"
{
  rtx addr;

  addr = plus_constant (operands[0], GET_MODE_SIZE (Pmode) * 3);
  mips_emit_move (gen_rtx_MEM (Pmode, addr), pic_offset_table_rtx);
  DONE;
}
:}

{:
;; Restore the gp that we saved above.  Despite the earlier comment, it seems
;; that older code did recalculate the gp from $25.  Continue to jump through
;; $25 for compatibility (we lose nothing by doing so).
:}
concrete builtin_longjmp.exp overrides builtin_setjmp_setup.exp {
	root.1.mode:=NULL;
}
{:
  "TARGET_USE_GOT"
{
  /* The elements of the buffer are, in order:  */
  int W = GET_MODE_SIZE (Pmode);
  rtx fp = gen_rtx_MEM (Pmode, operands[0]);
  rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 1*W));
  rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 2*W));
  rtx gpv = gen_rtx_MEM (Pmode, plus_constant (operands[0], 3*W));
  rtx pv = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);
  /* Use gen_raw_REG to avoid being given pic_offset_table_rtx.
     The target is bound to be using $28 as the global pointer
     but the current function might not be.  */
  rtx gp = gen_raw_REG (Pmode, GLOBAL_POINTER_REGNUM);

  /* This bit is similar to expand_builtin_longjmp except that it
     restores $gp as well.  */
  mips_emit_move (hard_frame_pointer_rtx, fp);
  mips_emit_move (pv, lab);
  emit_stack_restore (SAVE_NONLOCAL, stack);
  mips_emit_move (gp, gpv);
  emit_use (hard_frame_pointer_rtx);
  emit_use (stack_pointer_rtx);
  emit_use (gp);
  emit_indirect_jump (pv);
  DONE;
}
:}
{:

;;
;;  ....................
;;
;;	Function prologue/epilogue
;;
;;  ....................
;;
:}
concrete prologue.exp instantiates sequence {
	root (const_int:1);
}
{:
  ""
{
  mips_expand_prologue ();
  DONE;
}
:}
{:
;; Block any insns from being moved before this point, since the
;; profiling call to mcount can use various registers that aren't
;; saved or used to pass arguments.
:}
concrete blockage.insn instantiates unspec_volatile {
	root ((const_int:0, <UNSPEC_BLOCKAGE>));
}
{:
  ""
  ""
  [(set_attr "type" "ghost")
   (set_attr "mode" "none")]
:}
concrete epilogue.exp instantiates sequence {
	root (const_int:2);
}
{:
  ""
{
  mips_expand_epilogue (false);
  DONE;
}
:}
concrete sibcall_epilogue.exp instantiates sequence {
	root (const_int:2);
}
{:
  ""
{
  mips_expand_epilogue (true);
  DONE;
}
:}
{:
;; Trivial return.  Make it look like a normal return insn as that
;; allows jump optimizations to work better.
:}

concrete return.exp instantiates sequence {
	root (simple_return);
}
{:
  "mips_can_use_return_insn ()"
  { mips_expand_before_return (); }
:}

concrete simple_return.exp instantiates sequence {
	root (simple_return);
}
{:
  ""
  { mips_expand_before_return (); }
:}

concrete *<optab>.insn instantiates sequence {
	root (any_return);
}
{:
  ""
  "%*j\t$31%/"
  [(set_attr "type"	"jump")
   (set_attr "mode"	"none")]
:}
{:
;; Normal return.
:}

abstract sequence_use extends sequence {
  root.1:=sequence; root.2:=use;
}

concrete <optab>_internal.insn instantiates sequence_use {
	root ((any_return), o_mode_register_operand:NULL:"");
}
{:
  ""
  "%*j\t%0%/"
  [(set_attr "type"	"jump")
   (set_attr "mode"	"none")]
:}
{:
;; Exception return.
:}
abstract sequence_unspec_volatile extends sequence {
  root.1:=sequence; root.2:=unspec_volatile;
}
concrete mips_eret.insn instantiates sequence_unspec_volatile {
	root ((return), (const_int:0, <UNSPEC_ERET>));
}
{:
  ""
  "eret"
  [(set_attr "type"	"trap")
   (set_attr "mode"	"none")]
:}
{:
;; Debug exception return.
:}
concrete mips_deret.insn instantiates sequence_unspec_volatile {
	root ((return), (const_int:0, <UNSPEC_DERET>));
}
{:
  ""
  "deret"
  [(set_attr "type"	"trap")
   (set_attr "mode"	"none")]
:}
{:
;; Disable interrupts.
:}
concrete mips_di.insn instantiates unspec_volatile {
	root ((const_int:0, <UNSPEC_DI>));
}
{:
  ""
  "di"
  [(set_attr "type"	"trap")
   (set_attr "mode"	"none")]
:}
{:
;; Execution hazard barrier.
:}
concrete mips_ehb.insn instantiates unspec_volatile {
	root ((const_int:0, <UNSPEC_EHB>));
}
{:
  ""
  "ehb"
  [(set_attr "type"	"trap")
   (set_attr "mode"	"none")]
:}
{:
;; Read GPR from previous shadow register set.
:}
concrete mips_rdpgpr.insn instantiates set_unspec_volatile2 {
	root (register_operand:SI:"=d", (register_operand:SI:"d", <UNSPEC_RDPGPR>));
	root.2.mode:=SI;
}
{:
  ""
  "rdpgpr\t%0,%1"
  [(set_attr "type"	"move")
   (set_attr "mode"	"SI")]
:}
{:
;; Move involving COP0 registers.
:}
concrete cop0_move.insn instantiates set_unspec_volatile2 {
	root (register_operand:SI:"=B,d", (register_operand:SI:"d,B",<UNSPEC_COP0>));
	root.2.mode:=SI;
}
{:
  ""
{ return mips_output_move (operands[0], operands[1]); }
  [(set_attr "type"	"mtc,mfc")
   (set_attr "mode"	"SI")]
:}
{:
;; This is used in compiling the unwind routines.
:}
concrete eh_return.exp instantiates use {
	root (general_operand:NULL:"");
}
{:
  ""
{
  if (GET_MODE (operands[0]) != word_mode)
    operands[0] = convert_to_mode (word_mode, operands[0], 0);
  if (TARGET_64BIT)
    emit_insn (gen_eh_set_lr_di (operands[0]));
  else
    emit_insn (gen_eh_set_lr_si (operands[0]));
  DONE;
}
:}
{:
;; Clobber the return address on the stack.  We can't expand this
;; until we know where it will be put in the stack frame.
:}

abstract unspec_clobber extends sequence {
  root.1:=unspec; root.2:=clobber;
}

concrete eh_set_lr_si.insn instantiates unspec_clobber {
	root ((register_operand:SI:"d", <UNSPEC_EH_RETURN>), 1=SI:"=&d");
}
{:
  "! TARGET_64BIT"
  "#"
:}
concrete eh_set_lr_di.insn instantiates unspec_clobber {
	root ((register_operand:DI:"d", <UNSPEC_EH_RETURN>), 1=DI:"=&d");
}
{:
  "TARGET_64BIT"
  "#"
:}

concrete .split instantiates.in unspec_clobber {
	root ((register_operand:NULL:"", <UNSPEC_EH_RETURN>), 1=NULL:"");
}
cmd_spec.in
{:
  "reload_completed"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_set_return_address (operands[0], operands[1]);
  DONE;
}
:}

concrete exception_receiver.exp instantiates sequence {
	root (const_int:0);
}
{:
  "TARGET_USE_GOT"
{
  /* See the comment above load_call<mode> for details.  */
  emit_insn (gen_set_got_version ());

  /* If we have a call-clobbered $gp, restore it from its save slot.  */
  if (HAVE_restore_gp_si)
    emit_insn (gen_restore_gp_si ());
  else if (HAVE_restore_gp_di)
    emit_insn (gen_restore_gp_di ());
  DONE;
}
:}

concrete nonlocal_goto_receiver.exp instantiates sequence {
  root (const_int:0);
}
{:
  "TARGET_USE_GOT"
{
  /* See the comment above load_call<mode> for details.  */
  emit_insn (gen_set_got_version ());
  DONE;
}
:}
{:
;; Restore $gp from its .cprestore stack slot.  The instruction remains
;; volatile until all uses of $28 are exposed.
:}
abstract set_unspec_volatile2_clobber extends sequence {
  root.1:=set_unspec_volatile2; root.2:=clobber;
}
concrete restore_gp_<mode>.insn_and_split instantiates.in set_unspec_volatile2_clobber {
  root (reg (P:28), (const_int:0, <UNSPEC_RESTORE_GP>), 0=P:"=&d");
  root.1.2.mode:=P;
}
cmd_spec.in
{:
  "TARGET_CALL_CLOBBERED_GP"
  "#"
  "&& epilogue_completed"
:}
instantiates.out sequence {
  root (const_int:0);
}
cmd_spec.out
{:
{
  mips_restore_gp_from_cprestore_slot (operands[0]);
  DONE;
}
  [(set_attr "type" "ghost")]
:}
{:
;; Move between $gp and its register save slot.
:}
concrete move_gp<mode>.insn_and_split instantiates.in set_unspec2 {
  root (nonimmediate_operand:GPR:"=d,m", (move_operand:GPR:"m,d", <UNSPEC_MOVE_GP>));
  root.2.mode:=GPR;
}
cmd_spec.in
{:
  ""
  { return mips_must_initialize_gp_p () ? "#" : ""; }
  "mips_must_initialize_gp_p ()"
:}
instantiates.out sequence {
  root (const_int:0);
}
cmd_spec.out
{:
{
  mips_emit_move (operands[0], operands[1]);
  DONE;
}
  [(set_attr "type" "ghost")]
:}
{:

;;
;;  ....................
;;
;;	FUNCTION CALLS
;;
;;  ....................

;; Instructions to load a call address from the GOT.  The address might
;; point to a function or to a lazy binding stub.  In the latter case,
;; the stub will use the dynamic linker to resolve the function, which
;; in turn will change the GOT entry to point to the function's real
;; address.
;;
;; This means that every call, even pure and constant ones, can
;; potentially modify the GOT entry.  And once a stub has been called,
;; we must not call it again.
;;
;; We represent this restriction using an imaginary, fixed, call-saved
;; register called GOT_VERSION_REGNUM.  The idea is to make the register
;; live throughout the function and to change its value after every
;; potential call site.  This stops any rtx value that uses the register
;; from being computed before an earlier call.  To do this, we:
;;
;;    - Ensure that the register is live on entry to the function,
;;	so that it is never thought to be used uninitalized.
;;
;;    - Ensure that the register is live on exit from the function,
;;	so that it is live throughout.
;;
;;    - Make each call (lazily-bound or not) use the current value
;;	of GOT_VERSION_REGNUM, so that updates of the register are
;;	not moved across call boundaries.
;;
;;    - Add "ghost" definitions of the register to the beginning of
;;	blocks reached by EH and ABNORMAL_CALL edges, because those
;;	edges may involve calls that normal paths don't.  (E.g. the
;;	unwinding code that handles a non-call exception may change
;;	lazily-bound GOT entries.)  We do this by making the
;;	exception_receiver and nonlocal_goto_receiver expanders emit
;;	a set_got_version instruction.
;;
;;    - After each call (lazily-bound or not), use a "ghost"
;;	update_got_version instruction to change the register's value.
;;	This instruction mimics the _possible_ effect of the dynamic
;;	resolver during the call and it remains live even if the call
;;	itself becomes dead.
;;
;;    - Leave GOT_VERSION_REGNUM out of all register classes.
;;	The register is therefore not a valid register_operand
;;	and cannot be moved to or from other registers.
:}
concrete load_call<mode>.insn instantiates set_unspec2 {
	root (register_operand:P:"=d", (register_operand:P:"d",
		immediate_operand:P:"", reg(SI:GOT_VERSION_REGNUM), <UNSPEC_LOAD_CALL>));
	root.2.mode:=P;
}
{:
  "TARGET_USE_GOT"
  "<load>\t%0,%R2(%1)"
  [(set_attr "got" "load")
   (set_attr "mode" "<MODE>")]
:}
concrete set_got_version.insn instantiates set_unspec_volatile2 {
	root (reg(SI:GOT_VERSION_REGNUM), (const_int:0, <UNSPEC_SET_GOT_VERSION>));
	root.2.mode:=SI;
}
{:
  "TARGET_USE_GOT"
  ""
  [(set_attr "type" "ghost")]
:}
concrete update_got_version.insn instantiates set_unspec2 {
	root (reg(SI:GOT_VERSION_REGNUM), (reg (SI:GOT_VERSION_REGNUM),
		<UNSPEC_UPDATE_GOT_VERSION>)); root.2.mode:=SI;
}
{:
  "TARGET_USE_GOT"
  ""
  [(set_attr "type" "ghost")]
:}
{:
;; Sibling calls.  All these patterns use jump instructions.

;; If TARGET_SIBCALLS, call_insn_operand will only accept constant
;; addresses if a direct jump is acceptable.  Since the 'S' constraint
;; is defined in terms of call_insn_operand, the same is true of the
;; constraints.

;; When we use an indirect jump, we need a register that will be
;; preserved by the epilogue.  Since TARGET_USE_PIC_FN_ADDR_REG forces
;; us to use $25 for this purpose -- and $25 is never clobbered by the
;; epilogue -- we might as well use it for !TARGET_USE_PIC_FN_ADDR_REG
;; as well.
:}
abstract parallel_call1_use_x2 extends parallel {
	root.1:=call; root.2:=use; root.3:=use;
}
concrete sibcall.exp instantiates parallel_call1_use_x2 {
	root (NULL:NULL:"", NULL:NULL:"",NULL:NULL:"",NULL:NULL:"");
}
{:
  "TARGET_SIBCALLS"
{
  mips_expand_call (MIPS_CALL_SIBCALL, NULL_RTX, XEXP (operands[0], 0),
		    operands[1], operands[2], false);
  DONE;
}
:}
abstract call_mem1 extends call {
	root.1:=mem;
}
concrete sibcall_internal.insn instantiates call_mem1 {
	root (call_insn_operand:NULL:"j,S", NULL:NULL:""); root.1.mode:=SI;
}
{:
  "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
  { return MIPS_CALL ("j", operands, 0, 1); }
  [(set_attr "jal" "indirect,direct")
   (set_attr "jal_macro" "no")]
:}
abstract parallel_set_call2_use extends parallel {
	root.1:=set_call2; root.2:=use;
}
concrete sibcall_value.exp instantiates parallel_set_call2_use {
	root (NULL:NULL:"",NULL:NULL:"",NULL:NULL:"",NULL:NULL:"");
}
{:
  "TARGET_SIBCALLS"
{
  mips_expand_call (MIPS_CALL_SIBCALL, operands[0], XEXP (operands[1], 0),
		    operands[2], operands[3], false);
  DONE;
}
:}
abstract set_call2_mem1 extends set_call2 {
	root.2.1:=mem;
}
concrete sibcall_value_internal.insn instantiates set_call2_mem1 {
	root (register_operand:NULL:"", call_insn_operand:NULL:"j,S",
		NULL:NULL:""); root.2.1.mode:=SI;
}
{:
  "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
  { return MIPS_CALL ("j", operands, 1, 2); }
  [(set_attr "jal" "indirect,direct")
   (set_attr "jal_macro" "no")]
:}
abstract set_call2_mem1_x2 extends sequence {
	root.1:=set_call2_mem1; root.2:=set_call2_mem1;
}
concrete sibcall_value_multiple_internal.insn instantiates set_call2_mem1_x2 {
	root (register_operand:NULL:"", call_insn_operand:NULL:"j,S", NULL:NULL:"",
		register_operand:NULL:"", duplicate 1, duplicate 2);
	root.1.2.1.mode:=SI; root.2.2.1.mode:=SI;
}
{:
  "TARGET_SIBCALLS && SIBLING_CALL_P (insn)"
  { return MIPS_CALL ("j", operands, 1, 2); }
  [(set_attr "jal" "indirect,direct")
   (set_attr "jal_macro" "no")]
:}
concrete call.exp overrides sibcall.exp {
	root.1.1.1.predicate:=NULL;
}
{:
  ""
{
  mips_expand_call (MIPS_CALL_NORMAL, NULL_RTX, XEXP (operands[0], 0),
		    operands[1], operands[2], false);
  DONE;
}
:}

{:
;; This instruction directly corresponds to an assembly-language "jal".
;; There are four cases:
;;
;;    - -mno-abicalls:
;;	  Both symbolic and register destinations are OK.  The pattern
;;	  always expands to a single mips instruction.
;;
;;    - -mabicalls/-mno-explicit-relocs:
;;	  Again, both symbolic and register destinations are OK.
;;	  The call is treated as a multi-instruction black box.
;;
;;    - -mabicalls/-mexplicit-relocs with n32 or n64:
;;	  Only "jal $25" is allowed.  This expands to a single "jalr $25"
;;	  instruction.
;;
;;    - -mabicalls/-mexplicit-relocs with o32 or o64:
;;	  Only "jal $25" is allowed.  The call is actually two instructions:
;;	  "jalr $25" followed by an insn to reload $gp.
;;
;; In the last case, we can generate the individual instructions with
;; a define_split.  There are several things to be wary of:
;;
;;   - We can't expose the load of $gp before reload.  If we did,
;;     it might get removed as dead, but reload can introduce new
;;     uses of $gp by rematerializing constants.
;;
;;   - We shouldn't restore $gp after calls that never return.
;;     It isn't valid to insert instructions between a noreturn
;;     call and the following barrier.
;;
;;   - The splitter deliberately changes the liveness of $gp.  The unsplit
;;     instruction preserves $gp and so have no effect on its liveness.
;;     But once we generate the separate insns, it becomes obvious that
;;     $gp is not live on entry to the call.
;;
:}
abstract call_mem1_clobber extends sequence {
	root.1:=call_mem1; root.2:=clobber;
}
abstract call_mem1_clobber_x2 extends sequence {
	root.1:=call_mem1; root.2:=clobber; root.3:=clobber;
}
concrete call_internal.insn_and_split instantiates.in call_mem1_clobber {
	root (call_insn_operand:NULL:"c,S", NULL:NULL:"", reg(SI:RETURN_ADDR_REGNUM));
	root.1.1.mode:=SI;
}
cmd_spec.in
{:
  ""
  { return TARGET_SPLIT_CALLS ? "#" : MIPS_CALL ("jal", operands, 0, 1); }
  "reload_completed && TARGET_SPLIT_CALLS"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_split_call (curr_insn, gen_call_split (operands[0], operands[1]));
  DONE;
}
  [(set_attr "jal" "indirect,direct")]
:}

concrete call_split.insn instantiates call_mem1_clobber_x2 {
	root (call_insn_operand:NULL:"c,S", NULL:NULL:"", reg(SI:RETURN_ADDR_REGNUM),
		reg(SI:28)); root.1.1.mode:=SI;
}
{:
  "TARGET_SPLIT_CALLS"
  { return MIPS_CALL ("jal", operands, 0, 1); }
  [(set_attr "jal" "indirect,direct")
   (set_attr "jal_macro" "no")]
:}
{:
;; A pattern for calls that must be made directly.  It is used for
;; MIPS16 calls that the linker may need to redirect to a hard-float
;; stub; the linker relies on the call relocation type to detect when
;; such redirection is needed.
:}

abstract call_mem1_sequence_clobber extends sequence {
	root.1:=call_mem1; root.2:=sequence; root.3:=clobber;
}

concrete call_internal_direct.insn_and_split instantiates.in call_mem1_sequence_clobber {
	root (const_call_insn_operand:NULL:"",NULL:NULL:"", (const_int:1), reg (SI:RETURN_ADDR_REGNUM));
	root.1.1.mode:=SI;
}
cmd_spec.in
{:
  ""
  { return TARGET_SPLIT_CALLS ? "#" : MIPS_CALL ("jal", operands, 0, -1); }
  "reload_completed && TARGET_SPLIT_CALLS"
:}
instantiates.out sequence {
	root (const_int:0);
}  
cmd_spec.out
{:
{
  mips_split_call (curr_insn,
		   gen_call_direct_split (operands[0], operands[1]));
  DONE;
}
  [(set_attr "jal" "direct")]
:}
abstract call_mem1_sequence_clobber_x2 extends sequence {
	root.1:=call_mem1; root.2:=sequence; root.3:=clobber; root.4:=clobber;
}
concrete call_direct_split.insn instantiates call_mem1_sequence_clobber_x2 {
	root (const_call_insn_operand:NULL:"", NULL:NULL:"", (const_int:1),
		reg(SI:RETURN_ADDR_REGNUM), reg(SI:28)); root.1.1.mode:=SI;
}
{:
  "TARGET_SPLIT_CALLS"
  { return MIPS_CALL ("jal", operands, 0, -1); }
  [(set_attr "jal" "direct")
   (set_attr "jal_macro" "no")]
:}
abstract parallel_set_call2_use extends parallel {
	root.1:=set_call2; root.2:=use;
}
concrete call_value.exp instantiates parallel_set_call2_use {
	root (NULL:NULL:"",NULL:NULL:"",NULL:NULL:"",NULL:NULL:"");
}
{:
  ""
{
  mips_expand_call (MIPS_CALL_NORMAL, operands[0], XEXP (operands[1], 0),
		    operands[2], operands[3], false);
  DONE;
}
:}
{:
;; See comment for call_internal.
:}
abstract set_call2_mem1_clobber extends sequence {
	root.1:=set_call2_mem1; root.2:=clobber;
}
concrete call_value_internal.insn_and_split instantiates.in set_call2_mem1_clobber {
	root (register_operand:NULL:"", call_insn_operand:NULL:"c,S", NULL:NULL:"",
		reg(SI:RETURN_ADDR_REGNUM)); root.1.2.1.mode:=SI;
}
cmd_spec.in
{:
  ""
  { return TARGET_SPLIT_CALLS ? "#" : MIPS_CALL ("jal", operands, 1, 2); }
  "reload_completed && TARGET_SPLIT_CALLS"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_split_call (curr_insn,
		   gen_call_value_split (operands[0], operands[1],
					 operands[2]));
  DONE;
}
  [(set_attr "jal" "indirect,direct")]
:}
abstract set_call2_mem1_clobber_x2 extends sequence {
	root.1:=set_call2_mem1; root.2:=clobber; root.3:=clobber;
}
concrete call_value_split.insn instantiates set_call2_mem1_clobber_x2 {
	root (register_operand:NULL:"", call_insn_operand:NULL:"c,S",
		NULL:NULL:"", reg(SI:RETURN_ADDR_REGNUM), reg(SI:28));
	root.1.2.1.mode:=SI;
}
{:
  "TARGET_SPLIT_CALLS"
  { return MIPS_CALL ("jal", operands, 1, 2); }
  [(set_attr "jal" "indirect,direct")
   (set_attr "jal_macro" "no")]
:}

{:
;; See call_internal_direct.
:}
abstract set_call2_mem1_sequence_clobber extends sequence {
	root.1:=set_call2_mem1; root.2:=sequence; root.3:=clobber;
}

concrete call_value_internal_direct.insn_and_split instantiates.in set_call2_mem1_sequence_clobber {
	root (register_operand:NULL:"", const_call_insn_operand:NULL:"",NULL:NULL:"",
		(const_int:1), reg(SI:RETURN_ADDR_REGNUM));
	root.1.2.1.mode:=SI;
}
cmd_spec.in
{:
  ""
  { return TARGET_SPLIT_CALLS ? "#" : MIPS_CALL ("jal", operands, 1, -1); }
  "reload_completed && TARGET_SPLIT_CALLS"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_split_call (curr_insn,
		   gen_call_value_direct_split (operands[0], operands[1],
						operands[2]));
  DONE;
}
  [(set_attr "jal" "direct")]
:}
abstract set_call2_mem1_sequence_clobber_x2 extends sequence {
	root.1:=set_call2_mem1; root.2:=sequence; root.3:=clobber; root.4:=clobber;	
}
concrete call_value_direct_split.insn instantiates set_call2_mem1_sequence_clobber_x2 {
	root (register_operand:NULL:"", const_call_insn_operand:NULL:"",
		NULL:NULL:"", (const_int:1), reg(SI:RETURN_ADDR_REGNUM), 
		reg(SI:28)); root.1.2.1.mode:=SI;
}
{:
  "TARGET_SPLIT_CALLS"
  { return MIPS_CALL ("jal", operands, 1, -1); }
  [(set_attr "jal" "direct")
   (set_attr "jal_macro" "no")]
:}
{:
;; See comment for call_internal.
:}
abstract set_call2_mem1_x2_clobber extends sequence {
	root.1:=set_call2_mem1; root.2:=set_call2_mem1; root.3:=clobber;
}
concrete call_value_multiple_internal.insn_and_split instantiates.in set_call2_mem1_x2_clobber {
	root (register_operand:NULL:"", call_insn_operand:NULL:"c,S",
		NULL:NULL:"", register_operand:NULL:"", duplicate 1, duplicate 2,
		reg(SI:RETURN_ADDR_REGNUM));
	root.1.2.1.mode:=SI; root.2.2.1.mode:=SI;
}
cmd_spec.in
{:
  ""
  { return TARGET_SPLIT_CALLS ? "#" : MIPS_CALL ("jal", operands, 1, 2); }
  "reload_completed && TARGET_SPLIT_CALLS"
:}
instantiates.out sequence {
	root (const_int:0);
}
cmd_spec.out
{:
{
  mips_split_call (curr_insn,
		   gen_call_value_multiple_split (operands[0], operands[1],
						  operands[2], operands[3]));
  DONE;
}
  [(set_attr "jal" "indirect,direct")]
:}
abstract set_call2_mem1_x2_clobber_x2 extends sequence {
	root.1:=set_call2_mem1; root.2:=set_call2_mem1; root.3:=clobber; root.4:=clobber;
}
concrete call_value_multiple_split.insn instantiates set_call2_mem1_x2_clobber_x2 {
	root (register_operand:NULL:"", call_insn_operand:NULL:"c,S",
		NULL:NULL:"",register_operand:NULL:"", duplicate 1, duplicate 2,
		reg(SI:RETURN_ADDR_REGNUM), reg(SI:28));
	root.1.2.1.mode:=SI; root.2.2.1.mode:=SI;
}
{:
  "TARGET_SPLIT_CALLS"
  { return MIPS_CALL ("jal", operands, 1, 2); }
  [(set_attr "jal" "indirect,direct")
   (set_attr "jal_macro" "no")]
:}
{:
;; Call subroutine returning any type.
:}
abstract parallel_call1_sequence_x2 extends parallel {
	root.1:=call; root.2:=sequence; root.3:=sequence;
}
concrete untyped_call.exp instantiates parallel_call1_sequence_x2 {
	root (NULL:NULL:"", const_int:0, (NULL:NULL:""),(NULL:NULL:""));
}
{:
  ""
{
  int i;

  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));

  for (i = 0; i < XVECLEN (operands[2], 0); i++)
    {
      rtx set = XVECEXP (operands[2], 0, i);
      mips_emit_move (SET_DEST (set), SET_SRC (set));
    }

  emit_insn (gen_blockage ());
  DONE;
}
:}
{:

;;
;;  ....................
;;
;;	MISC.
;;
;;  ....................
;;
:}

concrete prefetch.insn instantiates prefetch {
	root (address_operand:QI:"p", const_int_operand:NULL:"n",
		const_int_operand:NULL:"n"); root.1.mode:=QI;
}
{:
  "ISA_HAS_PREFETCH && TARGET_EXPLICIT_RELOCS"
{
  if (TARGET_LOONGSON_2EF || TARGET_LOONGSON_3A)
    /* Loongson 2[ef] and Loongson 3a use load to $0 to perform prefetching.  */
    return "ld\t$0,%a0";
  operands[1] = mips_prefetch_cookie (operands[1], operands[2]);
  return "pref\t%1,%a0";
}
  [(set_attr "type" "prefetch")]
:}
abstract prefetch_plus1 extends prefetch {
	root.1:=plus;
}
concrete *prefetch_indexed_<mode>.insn instantiates prefetch_plus1 {
	root (register_operand:P:"d", register_operand:P:"d", const_int_operand:NULL:"n",
		const_int_operand:NULL:"n"); root.1.mode:=P;
}
{:
  "ISA_HAS_PREFETCHX && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT"
{
  operands[2] = mips_prefetch_cookie (operands[2], operands[3]);
  return "prefx\t%2,%1(%0)";
}
  [(set_attr "type" "prefetchx")]
:}
concrete nop.insn instantiates sequence {
	root (const_int:0);
}
{:
  ""
  "%(nop%)"
  [(set_attr "type"	"nop")
   (set_attr "mode"	"none")]
:}
{:
;; Like nop, but commented out when outside a .set noreorder block.
:}
concrete hazard_nop.insn instantiates sequence {
	root (const_int:1);
}
{:
  ""
  {
    if (mips_noreorder.nesting_level > 0)
      return "nop";
    else
      return "#nop";
  }
  [(set_attr "type"	"nop")]
:}
{:

;; MIPS4 Conditional move instructions.
:}
concrete *mov<GPR:mode>_on_<MOVECC:mode>.insn instantiates set_if_then_else2_match_operator1 {
	root (0=register_operand:GPR:"=d,d", (4=equality_operator, 
		1=register_operand:MOVECC:"<MOVECC:reg>,<MOVECC:reg>",
		const_int:0), 2=reg_or_0_operand:GPR:"dJ,0", 3=reg_or_0_operand:GPR:"0,dJ");
	root.2.mode:=GPR; root.2.1.mode:=MOVECC;
}
{:
  "ISA_HAS_CONDMOVE"
  "@
    mov%T4\t%0,%z2,%1
    mov%t4\t%0,%z3,%1"
  [(set_attr "type" "condmove")
   (set_attr "mode" "<GPR:MODE>")]
:}
concrete *mov<SCALARF:mode>_on_<MOVECC:mode>.insn overrides
*mov<GPR:mode>_on_<MOVECC:mode>.insn {
	GPR->SCALARF; allconstraints:=("=f,f", "<MOVECC:reg>,<MOVECC:reg>","f,0","0,f");
	root.2.2.predicate:=register_operand; root.2.3.predicate:=register_operand;
}
{:
  "ISA_HAS_FP_CONDMOVE"
  "@
    mov%T4.<fmt>\t%0,%2,%1
    mov%t4.<fmt>\t%0,%3,%1"
  [(set_attr "type" "condmove")
   (set_attr "mode" "<SCALARF:MODE>")]
:}
{:
;; These are the main define_expand's used to make conditional moves.
:}

abstract set_set_if_then_else2 extends sequence {
	root.1:=set; root.2:=set_if_then_else2;
}

concrete mov<mode>cc.exp instantiates set_set_if_then_else2 {
	root (duplicate 4, 1=comparison_operator:NULL:"", 0=register_operand:GPR:"",
		duplicate 5, reg_or_0_operand:GPR:"", reg_or_0_operand:GPR:"");
	root.2.2.mode:=GPR;
}
{:
  "ISA_HAS_CONDMOVE"
{
  mips_expand_conditional_move (operands);
  DONE;
}
:}
concrete mov<mode>cc.exp overrides mov<mode>cc.exp {
	GPR->SCALARF;root.2.2.2.predicate:=register_operand; 
	root.2.2.3.predicate:=register_operand;
}
{:
  "ISA_HAS_FP_CONDMOVE"
{
  mips_expand_conditional_move (operands);
  DONE;
}
:}
{:

;;
;;  ....................
;;
;;	mips16 inline constant tables
;;
;;  ....................
;;
:}
concrete consttable_tls_reloc.insn instantiates unspec_volatile {
	root ((tls_reloc_operand:NULL:"", const_int_operand:NULL:"", <UNSPEC_CONSTTABLE_INT>));
}
{:
  "TARGET_MIPS16_PCREL_LOADS"
  { return mips_output_tls_reloc_directive (&operands[0]); }
  [(set (attr "length") (symbol_ref "INTVAL (operands[1])"))]
:}
concrete consttable_int.insn overrides consttable_tls_reloc.insn {
	root.1.predicate:=consttable_operand;
}
{:
  "TARGET_MIPS16"
{
  assemble_integer (operands[0], INTVAL (operands[1]),
		    BITS_PER_UNIT * INTVAL (operands[1]), 1);
  return "";
}
  [(set (attr "length") (symbol_ref "INTVAL (operands[1])"))]
:}
concrete consttable_float.insn instantiates unspec_volatile {
	root ((consttable_operand:NULL:"", <UNSPEC_CONSTTABLE_FLOAT>));
}
{:
  "TARGET_MIPS16"
{
  REAL_VALUE_TYPE d;

  gcc_assert (GET_CODE (operands[0]) == CONST_DOUBLE);
  REAL_VALUE_FROM_CONST_DOUBLE (d, operands[0]);
  assemble_real (d, GET_MODE (operands[0]),
		 GET_MODE_BITSIZE (GET_MODE (operands[0])));
  return "";
}
  [(set (attr "length")
	(symbol_ref "GET_MODE_SIZE (GET_MODE (operands[0]))"))]
:}
concrete align.insn instantiates unspec_volatile {
	root ((const_int_operand:NULL:"", <UNSPEC_ALIGN>));
}
{:
  ""
  ".align\t%0"
  [(set (attr "length") (symbol_ref "(1 << INTVAL (operands[0])) - 1"))]
:}
concrete .split instantiates.in sequence {
	root (small_data_pattern:NULL:"");
}
cmd_spec.in
{:
  "reload_completed"
:}
instantiates.out sequence {
	root (duplicate 0);
}
cmd_spec.out
{:
  { operands[0] = mips_rewrite_small_data (operands[0]); }
:}
{:
;;
;;  ....................
;;
;;	MIPS16e Save/Restore
;;
;;  ....................
;;
(define_insn "*mips16e_save_restore"
  [(match_parallel 0 ""
       [(set (match_operand:SI 1 "register_operand")
	     (plus:SI (match_dup 1)
		      (match_operand:SI 2 "const_int_operand")))])]
  "operands[1] == stack_pointer_rtx
   && mips16e_save_restore_pattern_p (operands[0], INTVAL (operands[2]), NULL)"
  { return mips16e_output_save_restore (operands[0], INTVAL (operands[2])); }
  [(set_attr "type" "arith")
   (set_attr "extended_mips16" "yes")])

;; Thread-Local Storage

;; The TLS base pointer is accessed via "rdhwr $3, $29".  No current
;; MIPS architecture defines this register, and no current
;; implementation provides it; instead, any OS which supports TLS is
;; expected to trap and emulate this instruction.  rdhwr is part of the
;; MIPS 32r2 specification, but we use it on any architecture because
;; we expect it to be emulated.  Use .set to force the assembler to
;; accept it.
;;
;; We do not use a constraint to force the destination to be $3
;; because $3 can appear explicitly as a function return value.
;; If we leave the use of $3 implicit in the constraints until
;; reload, we may end up making a $3 return value live across
;; the instruction, leading to a spill failure when reloading it.
:}
abstract set_unspec2_set extends sequence {
	root.1:=set_unspec2; root.2:=set;
}
concrete tls_get_tp_<mode>.insn_and_split instantiates.in set_unspec2_clobber {
	root (register_operand:P:"=d",(const_int:0, <UNSPEC_TLS_GET_TP>), 
		reg(P:TLS_GET_TP_REGNUM)); root.1.2.mode:=P;
}
cmd_spec.in
{:
  "HAVE_AS_TLS && !TARGET_MIPS16"
  "#"
  "&& reload_completed"
:}
instantiates.out set_unspec2_set {
	root (reg(P:TLS_GET_TP_REGNUM),(const_int:0, <UNSPEC_TLS_GET_TP>),
		duplicate 0, reg(P:TLS_GET_TP_REGNUM)); root.1.2.mode:=P;
}
cmd_spec.out
{:
  ""
  [(set_attr "type" "unknown")
   ; Since rdhwr always generates a trap for now, putting it in a delay
   ; slot would make the kernel's emulation of it much slower.
   (set_attr "can_delay" "no")
   (set_attr "mode" "<MODE>")
   (set_attr "length" "8")]
:}

concrete *tls_get_tp_<mode>_split.insn instantiates set_unspec2 {
	root (reg(P:TLS_GET_TP_REGNUM), (const_int:0, <UNSPEC_TLS_GET_TP>));
	root.2.mode:=P;
}
{:
  "HAVE_AS_TLS && !TARGET_MIPS16"
  ".set\tpush\;.set\tmips32r2\t\;rdhwr\t$3,$29\;.set\tpop"
  [(set_attr "type" "unknown")
   ; See tls_get_tp_<mode>
   (set_attr "can_delay" "no")
   (set_attr "mode" "<MODE>")]
:}
{:
;; In MIPS16 mode, the TLS base pointer is accessed by a
;; libgcc helper function __mips16_rdhwr(), as 'rdhwr' is not
;; accessible in MIPS16.
;;
;; This is not represented as a call insn, to avoid the
;; unnecesarry clobbering of caller-save registers by a
;; function consisting only of: "rdhwr $3,$29; j $31; nop;"
;;
;; A $25 clobber is added to cater for a $25 load stub added by the
;; linker to __mips16_rdhwr when the call is made from non-PIC code.
:}
abstract set_unspec2_clobber_x3 extends sequence {
	root.1:=set_unspec2; root.2:=clobber; root.3:=clobber; root.4:=clobber;
}
abstract parallel_set_unspec2_clobber_x2 extends parallel {
	root.1:=set_unspec2; root.2:=clobber; root.3:=clobber; root.4:=set;
}
abstract parallel_set_unspec2_clobber_x2_set extends sequence {
	root.1:=parallel_set_unspec2_clobber_x2; root.2:=set;
}
concrete tls_get_tp_mips16_<mode>.insn_and_split 
instantiates.in set_unspec2_clobber_x3 {
	root (register_operand:P:"=d", (call_insn_operand:P:"dS",
		<UNSPEC_TLS_GET_TP>), reg(P:TLS_GET_TP_REGNUM), 
		reg(P:PIC_FUNCTION_ADDR_REGNUM), reg(P:RETURN_ADDR_REGNUM));
	root.1.2.mode:=P;
}
cmd_spec.in
{:
  "HAVE_AS_TLS && TARGET_MIPS16"
  "#"
  "&& reload_completed"
:}
instantiates.out parallel_set_unspec2_clobber_x2_set {
	root ((reg(P:TLS_GET_TP_REGNUM), (duplicate 1, <UNSPEC_TLS_GET_TP>),
		reg(P:PIC_FUNCTION_ADDR_REGNUM), reg(P:RETURN_ADDR_REGNUM)),
		duplicate 0, reg(P:TLS_GET_TP_REGNUM));
	root.1.1.2.mode:=P;
}
cmd_spec.out
{:
  ""
  [(set_attr "type" "multi")
   (set_attr "length" "16")
   (set_attr "mode" "<MODE>")]
:}
abstract set_unspec2_clobber_x2 extends sequence {
	root.1:=set_unspec2; root.2:=clobber; root.3:=clobber;
}
concrete *tls_get_tp_mips16_call_<mode>.insn instantiates
set_unspec2_clobber_x2 {
	root (reg(P:TLS_GET_TP_REGNUM), (call_insn_operand:P:"dS",
		<UNSPEC_TLS_GET_TP>),reg(P:PIC_FUNCTION_ADDR_REGNUM),
		reg(P:RETURN_ADDR_REGNUM));
	root.1.2.mode:=P;
}
{:
  "HAVE_AS_TLS && TARGET_MIPS16"
  { return MIPS_CALL ("jal", operands, 0, -1); }
  [(set_attr "type" "call")
   (set_attr "length" "12")
   (set_attr "mode" "<MODE>")]
:}

{:

;; Synchronization instructions.

(include "sync.md")

; The MIPS Paired-Single Floating Point and MIPS-3D Instructions.

(include "mips-ps-3d.md")

; The MIPS DSP Instructions.

(include "mips-dsp.md")

; The MIPS DSP REV 2 Instructions.

(include "mips-dspr2.md")

; MIPS fixed-point instructions.
(include "mips-fixed.md")

; ST-Microelectronics Loongson-2E/2F-specific patterns.
(include "loongson.md")

(define_c_enum "unspec" [
  UNSPEC_ADDRESS_FIRST
])
:}